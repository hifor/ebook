<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Gdip 编程基础 | 计算机电子书 - Hifor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="GDI+（Graphics Device Interface Plus，图形设备接口加）是 Windows XP 及以上版本操 作系统的图形子系统，也是传统.NET 框架的重要组成部分和窗体绘图的主要工具，负责在 屏幕和打印机上绘制图形图像和显示信息。顾名思义，GDI+是 Windows 早期版本所提供的 图形设备接口 GDI 的后续版本，是建立在 GDI 之上的一个高层图形子系统。 GDI+是一">
<meta name="keywords" content="cpp,mfc,gdip">
<meta property="og:type" content="article">
<meta property="og:title" content="Gdip 编程基础">
<meta property="og:url" content="http://hifor.net/2016-adc88f03/index.html">
<meta property="og:site_name" content="计算机电子书 - Hifor">
<meta property="og:description" content="GDI+（Graphics Device Interface Plus，图形设备接口加）是 Windows XP 及以上版本操 作系统的图形子系统，也是传统.NET 框架的重要组成部分和窗体绘图的主要工具，负责在 屏幕和打印机上绘制图形图像和显示信息。顾名思义，GDI+是 Windows 早期版本所提供的 图形设备接口 GDI 的后续版本，是建立在 GDI 之上的一个高层图形子系统。 GDI+是一">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/1-1-1.png">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/1-1-2.png">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/1-3.png">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_009.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_010.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_011.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_012.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_013.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_014.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/1-10.png">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_017.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_018.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_019.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/1-5-1-1.png">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/1-5-1-2.png">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_020.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_021.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_022.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_023.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_024.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_025.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_026.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_027.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_028.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_029.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_030.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/1-7-1-2.png">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_037.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_038.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_039.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_040.png">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_041.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_042.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_043.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_044.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_045.png">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_046.png">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/1-7-2-1.png">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/1-7-2-2.png">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_048.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_049.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_050.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_051.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_052.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_053.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_054.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_055.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_056.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_057.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_058.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_059.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_060.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_061.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_062.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_063.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_064.png">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_065.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_066.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/1-8-1.png">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_068.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_069.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_070.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_071.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_072.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_073.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_074.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_075.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_076.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_077.jpg">
<meta property="og:image" content="http://hifor.net/img/gdip-编程基础/Image_078.jpg">
<meta property="og:updated_time" content="2018-06-29T01:11:41.498Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Gdip 编程基础">
<meta name="twitter:description" content="GDI+（Graphics Device Interface Plus，图形设备接口加）是 Windows XP 及以上版本操 作系统的图形子系统，也是传统.NET 框架的重要组成部分和窗体绘图的主要工具，负责在 屏幕和打印机上绘制图形图像和显示信息。顾名思义，GDI+是 Windows 早期版本所提供的 图形设备接口 GDI 的后续版本，是建立在 GDI 之上的一个高层图形子系统。 GDI+是一">
<meta name="twitter:image" content="http://hifor.net/img/gdip-编程基础/1-1-1.png">
  
    <link rel="alternative" href="/ebook/atom.xml" title="计算机电子书 - Hifor" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//fonts.css.network/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/ebook/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer">

    <div id="header-inner">
      <div class="outer">
      <h1 id="logo-wrap"><a href="/" id="logo">计算机电子书 - Hifor</a></h1>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/ebook/../">Home</a>
        
          <a class="main-nav-link" href="/ebook/../ebook/">Ebook</a>
        
          <a class="main-nav-link" href="/ebook/../about/">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/ebook/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://hifor.net"></form>
      </div>
      </div>
    </div>

  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-gdip-编程基础" class="article article-type-post article-con" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/ebook/2016-adc88f03/" class="article-date">
  <time datetime="2016-02-24T08:55:29.000Z" itemprop="datePublished">2016-02-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Gdip 编程基础
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>GDI+（Graphics Device Interface Plus，图形设备接口加）是 Windows XP 及以上版本操 作系统的图形子系统，也是传统.NET 框架的重要组成部分和窗体绘图的主要工具，负责在 屏幕和打印机上绘制图形图像和显示信息。顾名思义，GDI+是 Windows 早期版本所提供的 图形设备接口 GDI 的后续版本，是建立在 GDI 之上的一个高层图形子系统。</p>
<p>GDI+是一种 API，分别通过一套 C++类和一套部署为托管代码的类来展现，这两套类 分别被称为 GDI+的“C++封装”和“托管类接口”。</p>
<p>GDI+不但在功能上比 GDI 要强大很多，而且在代码编写方面也更简单，因此会成为 Windows 图形图像程序开发的主要工具之一。由于篇幅所限，本书只简单介绍利用 MFC 进 行 GDI+编程的一些基本内容，也不讲 GDI+的 API 编程。基于 GDI+托管封装的.NET 窗体 绘图，将在第 18 章中再介绍。对 GDI+编程有兴趣的读者，可以参考如下图书：</p>
<ul>
<li><p>周鸣杨、赵景亮. 精通 GDI+编程. 清华大学出版社，2004 年 2 月（C++ / MFC）。</p>
</li>
<li><p>Mahesh Chand（韩江等译）. GDI+图形程序设计. 电子工业出版社，2005 年 3 月（C# / .NET）。</p>
</li>
</ul>
<p>本章将介绍 GDI+的结构和组成，讨论 GDI+的几个主要新增特性与功能，说明 GDI+给 Windows 图形图像程序的开发模式带来的变化。介绍 C++封装的 GDI+ API 的具体使用方法， 主要讲解二维矢量图形绘制和文字显示等基本内容。<a id="more"></a></p>
<p>GDI+的路径、区域、变换、图像处理和图元文件等高级编程内容，安排在下一章介绍。</p>
<h2 id="1-GDI-的结构与组成"><a href="#1-GDI-的结构与组成" class="headerlink" title="1. GDI+的结构与组成"></a>1. GDI+的结构与组成</h2><p>本节先介绍 GDI+的体系结构，再列出 C++封装的 GDI+ API 的具体组成。</p>
<h3 id="1-1-GDI-的结构"><a href="#1-1-GDI-的结构" class="headerlink" title="1.1 GDI+的结构"></a>1.1 GDI+的结构</h3><p>GDI+是建立在 GDI 之上的一种高层图形子系统，基础是 GDI+平面 API，有 C++和托 管两种封装。</p>
<p>注意，虽然 GDI+是 GDI 的发展，但是 GDI+并非设计来替代 GDI 的，它不能独立工作， 底层还得靠 GDI 实现。</p>
<p>（1）GDI+的体系结构</p>
<p>GDI+与 GDI 一样，都具有设备无关性。而且 GDI+是建立在 GDI 之上的一种高层接口， 供 Windows API 和.NET 框架调用。与 GDI 类似，GDI+主要提供了二维矢量图形、图像处 理和文字显示版式三类功能（参见图 14-1），只是 GDI+比 GDI 的功能更强大，且编程模式发生了改变。</p>
<p><img src="../img/gdip-编程基础/1-1-1.png" alt=""></p>
<p>图 14-1 GDI+的体系结构</p>
<p>（2）GDI+平面 API 与封装</p>
<p>GDI+提供（expose）了一个平面（flat）API，它包含大约 600 个函数，被实现在 Gdiplus.dll 中，声明在 Gdiplusflat.h 内。这些函数被包装到了前面讨论过的 GDI+ API 的 54 个 C++类的 集合之中。</p>
<p>作为 C++封装的替代方案，微软.NET 框架提供了 GDI+的一个托管代码封装类集，包 含大约 60 个类、50 个枚举和 8 个结构。它们分属于下列命名空间：System.Drawing、 System.Drawing.Drawing2D 、 System.Drawing.Imaging 、 System.Drawing.Text 和 System. Drawing.Printing。</p>
<p>GDI+的平面 API 与其 C++及托管封装的关系如图 14-2 所示。</p>
<p><img src="../img/gdip-编程基础/1-1-2.png" alt=""></p>
<p>图 14-2 GDI+的封装与使用</p>
<h2 id="1-2-GDI-的组成"><a href="#1-2-GDI-的组成" class="headerlink" title="1.2 GDI+的组成"></a>1.2 GDI+的组成</h2><p>GDI+的 C++封装，包含了 54 个类、12 个全局函数、（6 类）226 个图像常量、55 种枚 举和 19 种结构。GDI+的.NET 托管封装，则包含了大约 60 个类、50 个枚举和 8 个结构。这 两种封装都是基于 GDI+平面 API 的。本小节只介绍 GDI+的 C++封装，GDI+的托管封装将 在第 18 章的.NET 窗体绘图中有所涉及。</p>
<p>（1）类</p>
<p>GDI+的 C++封装中共有 54 个类，核心类是 Graphics，它是实际绘制直线、曲线、图形、 图像和文本的类。许多其它 GDI+类是与 Graphics 类一起使用的。例如，DrawLine 方法接收 Pen 对象，该对象中存有所要绘制的线条的属性（颜色、宽度、虚线线型等）。FillRectangle 方法可以接收指向 LinearGradientBrush 对象的指针，该对象与 Graphics 对象配合工作来用 一种渐变色填充矩形。Font 和 StringFormat 对象影响 Graphics 对象绘制文本的方式。Matrix 对象存储并操作 Graphics 对象的仿射变换——旋转、缩放和翻转图像。</p>
<p>GDI+还提供了用于组织图形数据的几种结构类（例如 Rect、Point 和 Size）。而且，某 些类的主要作用是结构化数据类型。例如，BitmapData 类是 Bitmap 类的帮助器，PathData 类是 GraphicsPath 类的帮助器。图 14-3 是 GDI+ API 类的层次结构图。</p>
<p>注意：在 GDI+、.NET、C#、Java 和 VB 中，都把类的成员函数称为方法。当我们在</p>
<p>C++中，使用 GDI+和.NET 框架类库中的类和功能时，也常常将其函数改称为方法。</p>
<p><img src="../img/gdip-编程基础/1-3.png" alt=""></p>
<p>图 14-3 GDI+类的层次结构</p>
<p>（2）全局函数</p>
<p>GDI+命名空间中的全局函数有 12 个，常用的有如下两个（其余的大多数与图像相关）：</p>
<ul>
<li><p>关闭 GDI+：GdiplusShutdown（清除 GDI+所使用的资源）。</p>
</li>
<li><p>启动 GDI+：GdiplusStartup（初始化 GDI+）。</p>
</li>
</ul>
<p>（3）常量、枚举和结构</p>
<p>GDI+中有 6 类共计 226 个图像常量（都被定义在头文件 GdiplusImaging.h 中），包括图 像 文 件 格式 常 量 11 个（ 如 ImageFormatBMP 、 ImageFormatGIF 、 ImageFormatJPEG 、 ImageFormatPNG、ImageFormatTIFF 等）、图像帧维常量 2 个、图像编码器常量 13 个、图</p>
<p>像像素格式常量 14 个、图像特性标志类型 9 个、图像特性标志 217 个。</p>
<p>GDI+定义了 55 种枚举类型，它们都是相关常数的集合。例如：PenType、BrushType、DashStyle、ImageType、LineCap、FillMode、ImageFlags 等。</p>
<p>GDI+ API 中还定义了 19 种结构，用于 GDI+的各种方法调用中。例如：ColorMap、 ColorMatrix、ColorPalette、Gdiplus Abort、GdiplusStartupInput、GdiplusStartupOutput 等。</p>
<h2 id="1-2-GDI-的特色"><a href="#1-2-GDI-的特色" class="headerlink" title="1.2 GDI+的特色"></a>1.2 GDI+的特色</h2><p>本节介绍 GDI+的几个主要新增特性与功能，说明 GDI+在编程模式上的改变。</p>
<h3 id="1-2-1-GDI-新增特性"><a href="#1-2-1-GDI-新增特性" class="headerlink" title="1.2.1 GDI+新增特性"></a>1.2.1 GDI+新增特性</h3><p>与 GDI 相比，GDI+新增的特性主要有渐变画刷、样条和贝塞尔曲线、持久路径、矩阵 变换、伸缩区域、α 混色和对多种图像格式的支持。</p>
<p>（1）渐变画刷</p>
<p><img src="../img/gdip-编程基础/Image_009.jpg" alt="image"></p>
<p>GDI+中新增加的渐变画刷（gradient brush，梯度刷），通过提供用于填充图形、路径和 区域的颜色线性渐变和路径渐变的画刷，扩展了 GDI 的功能。渐变画刷可用于绘制直线、 曲线和路径，参见图 14-4。</p>
<p><img src="../img/gdip-编程基础/Image_010.jpg" alt="image"></p>
<p>a)（水平）线性渐变 b)（贝塞尔）路径渐变</p>
<p>图 14-4 渐变画刷 图 14-5 基样条曲线与折线</p>
<p>（2）曲线方法</p>
<p>GDI+支持基样条（cardinal splines）和贝塞尔（Bezier）方法，可以由若干控制点生成 光滑的曲线，参见图 14-5。</p>
<p>（3）持久路径对象</p>
<p>GDI 中的路径（path）属于设备上下文，并且会在绘制时被毁坏。而 GDI+则可以创建 并维护多个与 Graphics 对象分开的持久（persistent）路径对象——GraphicsPath 对象，在绘 图操作时也不会破坏，因此可多次使用同一个 GraphicsPath 对象来绘制路径。</p>
<p>（4）变换和矩阵对象</p>
<p>GDI+提供了 Matrix（矩阵）对象，它是一种可以使（缩放、旋转和平移等）变换（transformation）简易灵活的强 大工具，矩 阵对象一般 与变换对 象联合使用 。例如，GraphicsPath 对象具有 Transform 方法，此方法接收 Matrix 对象作为参数。参见图 14-6。</p>
<p>（5）可伸缩区域</p>
<p>GDI+通过对可伸缩区域（scalable region）的支持极大地扩展了 GDI。在 GDI 中，区域 被存储在设备坐标中，而且，可应用于区域的惟一变换是平移。而 GDI+在全局坐标中存储 区域，并且允许区域发生任何可存储在变换矩阵中的变换（如缩放和旋转）。图 14-7 显示一 个区域在执行三种变换（缩放、旋转和平移）前后的情况。</p>
<p><img src="../img/gdip-编程基础/Image_011.jpg" alt="image"></p>
<p>图 14-6 路径变换</p>
<p><img src="../img/gdip-编程基础/Image_012.jpg" alt="image"></p>
<p>图 14-7 区域变换</p>
<p><img src="../img/gdip-编程基础/Image_013.jpg" alt="image"></p>
<p>图 14-8 不同透明度</p>
<p>（6）α混色</p>
<p>在图 14-7 中，可以在变换区域（用蓝色阴影画笔填充）中看到未变换区域（用红色填充），这是由 GDI+支持的α 混色（alpha blending，透明混合）实现的。使用α 混色，可以指定填充颜色的透明度。透明色与背景色相混合———填充色越透明，透出的背景色就越多。 图 14-8 显示四个用相同颜色（红色）填充、但透明层次不同的椭圆。</p>
<p>（7）丰富的图像格式支持</p>
<p>GDI+提供 Image、Bitmap 和 Metaf ile 类，可以用不同的格式加载、保存和操作图像。 GDI+支持 BMP、GIF、JPEG、EXIF、PNG、TIFF、ICON、WMF、EMF 共 9 种常见的图像 格式。这些已经被 ATL/MFC 中的基于 GDI+的 CImage 类所体现。</p>
<p>（8）GDI+的不足</p>
<p>虽然，相对于 GDI 来说，GDI+确实增加了许多新特性，而且功能更强大，使用也更方 便。但是，这并不等于 GDI+就能够完全代替 GDI。</p>
<p>因为 GDI+实际上是 GDI 的高层封装和功能扩展，GDI+的执行效率一般要低于 GDI 的。 另外，GDI+不支持图形的位运算，那么就不能进行异或绘图等操作。而且在 Visual C++中， GDI+还不直接支持双缓存机制（如内存 DC 和显示 DC），这将大大影响 GDI+在高速图形、 图像、动画和视频等方面的应用。</p>
<h3 id="1-2-2-编程模式的改变"><a href="#1-2-2-编程模式的改变" class="headerlink" title="1.2.2 编程模式的改变"></a>1.2.2 编程模式的改变</h3><p>GDI+的出现，也使基于 GDI 的编程模式产生了很大变化：GDI+用一个“无状态模式”， 取代了 GDI 中（需要先将各种工具和项目选入 DC 对象后，才能进行绘图的）“状态模式”。 主要体现在以下几个方面：</p>
<p>（1）DC 句柄和图形对象</p>
<p>设备上下文（DC）是 GDI 中使用的一种结构，用于存储与特定显示设备相关的的绘制 工具及属性的信息，用于屏幕显示的 DC 还与特定窗口相关联。为了使用 GDI API 进行绘图， 必须首先获得一个 DC 的句柄（HDC），然后将该句柄作为参数，传递给实际进行绘图的 GDI 函数。在 MFC 中，DC 及其绘图功能被封装在 CDC 类中，DC 句柄成为了成员变量，绘图 函数变成了方法，不再需要显式传递 HDC 参数。</p>
<p>使用 GDI+，不需要再（直接）使用句柄或设备上下文，而是只需（通过 HDC）创建一个 Graphics 对象，然后用熟悉的面向对象方式来调用其中的各种绘图方法，例如：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myGraphicsObject.DrawLine(&amp;pen, <span class="keyword">x</span><span class="number">1</span>, y<span class="number">1</span>, <span class="keyword">x</span><span class="number">2</span>, y<span class="number">2</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>正如 DC 是 GDI 的核心，Graphics 对象也位于 GDI+的核心。DC 和 Graphics 对象的作 用相似，但在使用设备上下文（GDI）的基于句柄的编程模式和使用 Graphics 对象（GDI+） 的面向对象的编程模型之间，存在一些基本的差异。</p>
<p>Graphics 对象（像 DC 一样）与屏幕上的特定窗口关联，并具有指定如何绘制项目的属 性（如 SmoothingMode 和 TextRenderingHint）。但是，Graphics 对象不受笔、刷、路径、图 像或字体的约束，这与设备上下文不同。例如，使用设备上下文绘制线条之前，必须先调用 SelectObject 将笔选入 DC 中，以使笔对象和 DC 关联。在设备上下文中绘制的所有线条均 使用该笔，直到选择另一支不同的笔为止。在 GDI+中，将 Pen 对象作为参数传递给 Graphics 类的 DrawLine 等画线方法。可以在一系列的 DrawLine 调用的每个调用中，使用不同的 Pen 对象，而不必将给定的 Pen 对象与 Graphics 对象关联。</p>
<p>（2）画线的两种方法</p>
<p>下面每个示例都从点(20, 10)到点(200, 100)绘制一条宽为 3 的红色线条。第一个示例调 用 GDI，第二个示例则通过托管类接口调用 GDI+，这里都使用 MFC。也可以不使用 MFC， 而直接用 API 来进行 GDI+绘图（由于篇幅有限，这里就不介绍了）。</p>
<p>1）用 GDI 画线</p>
<p>利用 MFC 进行 GDI 绘图，步骤与 API 的差不多，只是 MFC 将各种 GDI 功能封装到了 不同的类中。例如，笔的类为 CPen、点的类为 CPoint、设备上下文的类为 CDC。而且所有 的绘图函数都被封在 CDC 类中，所以只能作为其对象的方法才能被使用，当然也就不用再 带 HDC 句柄作为输入参数了。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CDC *pDC = GetDC(); <span class="comment">// 获取 DC 对象</span></span><br><span class="line">CPen pen(PS_SOLID, <span class="number">3</span>, RGB(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>)); <span class="comment">// 创建笔</span></span><br><span class="line">pDC-&gt;SelectObject(&amp;pen); <span class="comment">// 选笔入 DC</span></span><br><span class="line">pDC-&gt;MoveTo(<span class="number">20</span>, <span class="number">10</span>); <span class="comment">// 将当前点移到直线的起点</span></span><br><span class="line">pDC-&gt;LineTo(<span class="number">200</span>, <span class="number">100</span>); <span class="comment">// 从当前点画线到直线的终点</span></span><br></pre></td></tr></table></figure>
<p>2）用 GDI+画线</p>
<p>利用 MFC 进行 GDI+绘图，步骤与 API 的差不多。只是代码改在 OnDraw 函数中，而且获取 DC 句柄的方法不同。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CDC *pDC = GetDC(); <span class="comment">// 获取 DC 对象</span></span><br><span class="line">Graphics myGraphics(pDC-&gt;m_hDC); <span class="comment">// 利用 DC 句柄创建图形对象</span></span><br><span class="line">Pen myPen(Color(<span class="number">255</span>, <span class="number">0</span> , <span class="number">0</span>), <span class="number">3</span>); <span class="comment">// 创建笔</span></span><br><span class="line">myGraphics.DrawLine(&amp;myPen, <span class="number">20</span>, <span class="number">10</span>, <span class="number">200</span>, <span class="number">100</span>); <span class="comment">// 画直线</span></span><br></pre></td></tr></table></figure>
<p>（3）作为参数的绘图工具</p>
<p>前面的示例显示：在 GDI+中，创建和维护 Pen 对象，可以与提供绘制方法的 Graphics 对象分开。同样，创建和维护 Brush、GraphicsPath、Image 和 Font 对象也可以与 Graphics 对象分开，Graphics 类提供的许多绘制方法，都将笔、刷、路径、图像和字体等对象，作为 参数接收。例如，Brush 对象作为参数传递至 FillRectangle 方法，GraphicPath 对象作为参数 传递至 DrawPath 方法。同样，Image 和 Font 对象传递至 DrawImage 和 DrawString 方法。</p>
<p>这与 GDI 不同，在 GDI 中，需要先将笔、刷、路径、图像或字体等 GDI 工具对象选入 DC，然后（API）将 DC 的句柄作为参数传递至绘制函数或（MFC）采用 CDC 类对象的函 数使用 DC 中当前的笔、刷、路径、图像或字体来绘图。</p>
<p>（4）无当前位置</p>
<p>GDI+从总体上已经放弃了当前位置的概念，如在前面所述的 DrawLine 方法中线条的起 点和终点均被作为参数接收。这与 GDI 方案不同，在 GDI 中，调用 MoveToEx(hdc, x1, y1, NULL) 或 pDC-&gt;MoveTo(x1, y1)来设置当前笔位置之后，再调用 LineTo(hdc, x2 , y2) 或 pDC-&gt;LineTo(x2, y2)来绘制一条从(x1, y1)到(x2 , y2)的线条。</p>
<p>（5）绘制和填充的不同方法</p>
<p>GDI 的 Rectangle 和 Ellipse 等函数，可一步完成绘制轮廓和填充内部的功能。轮廓由当 前选定的笔绘制，而内部则由当前选定的刷来填充。GDI+则必须分别调用绘制轮廓和填充 内部的两个不同方法来做到这一点。例如，Graphics 类的 DrawRectangle 方法将 Pen 对象作 为其参数之一，而 FillRectangle 方法将 Brush 对象作为其参数之一。所以在绘制轮廓和填充 图形内部时，GDI+要比 GDI 更灵活，但也更麻烦。</p>
<p>（6）构造区域</p>
<p>GDI 提供几种用于创建区域的 函数（在 MFC 中，它们被 封装在 CRng 类里）： CreateRectRgn 、 CreateEllpticRgn 、 CreateRoundRectRgn 、 CreatePolygonRgn 和 CreatePolyPolygonRgn。您或许希望 GDI+中的 Region 类也有类似的构造函数，将矩形、椭 圆、圆角矩形和多边形作为参数接收，但事实并非如此。GDI+中的 Region 类提供一个接收 Rectangle 对象的构造函数和另一个接收 GraphicsPath 对象的构造函数。如果想基于椭圆、 圆角矩形或多边形构造区域，可以通过创建一个 GraphicsPath 对象（可包含椭圆的对象等）， 然后将其传递至 Region 构造函数来轻松实现。</p>
<p>GDI+通过组合图形和路径，使得构成复杂区域十分简单。Region 类具有 Union 和 Intersect 方法，可用于扩展具有路径的现有区域或其它区域。GDI+方案一个很好的功能就是 GraphicsPath 对象在作为参数传递至 Region 构造函数时不会被破坏（在 GDI 中，可以使用 PathToRegion 方法将路径转换为区域，但在此过程中，路径将被破坏）。另外，GraphicsPath 对象在作为参数传递给 Union 或 Intersect 方法时也不会被破坏，因此，在一些单独的区域中， 可以将给定的路径作为构造块使用。例如：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Region region1(rect1)<span class="comment">; </span></span><br><span class="line">Region region2(rect2)<span class="comment">; </span></span><br><span class="line">region1.Union(onePath)<span class="comment">; </span></span><br><span class="line">region2.Intersect(onePath)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h2 id="1-3-GDI-的-MFC-编程"><a href="#1-3-GDI-的-MFC-编程" class="headerlink" title="1.3 GDI+的 MFC 编程"></a>1.3 GDI+的 MFC 编程</h2><p>本节介绍利用 MFC 进行 GDI+编程的必要的准备，并通过例子说明 GDI+编程的具体步 骤，最后给出如何解决存在的 new 操作符问题的方法。</p>
<p>C++封装的 GDI+的（英文）帮助内容，位于 VS08 的“目录/Win32 和 COM 开发/Graphics and Multimedia/GDI+”，主要的参考资料位于其子目录“GDI+ Reference”中。</p>
<h3 id="1-3-1-设置与初始化"><a href="#1-3-1-设置与初始化" class="headerlink" title="1.3.1 设置与初始化"></a>1.3.1 设置与初始化</h3><p>封装了 GDI+ API 的各种 C++类、函数、常量、枚举和结构，都被定义在 Gdiplus.h 头 文件所包含的一系列头文件中。所以，采用 MFC 进行 GDI+编程，必须包含 Gdiplus.h 头文 件。</p>
<p>从 14.1.2 的有关 GDI+平面 API 的讨论可知，封装在 GDI+类中方法，最后都需要调用GDI+平面 API 中的相关底层函数，才能完成实际的操作。所以，为了运行 GDI+应用程序，在操作系统平台中，必须安装动态链接库 Gdiplus.dll。对 Windows XP 及以上版本，该 DLL已经自动被操作系统包含。</p>
<p>该动态链接库所对应的静态库文件为 GdiPlus.lib，而且它在 VC08 及之前的早期版本中 不是 C++和 MFC 的默认链接库。所以，对早期的 VC 版本必须在项目设置，添加该库作为 链接器输入的附加依赖项。但是对 VC08 SP1 及 VC10，该库已经成为标准链接库之一，不 必再为链接器输入的附加依赖项添加此库。</p>
<p>因为在 Gdiplus.h 头文件中，将所有的 GDI+的类、函数、常量、枚举和结构等都定义在 了命名空间 Gdiplus 中。所以，一般在 GDI+程序中，都应该使用如下的命名空间声明：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">Gdiplus</span>;</span><br></pre></td></tr></table></figure>
<p>（1）VC 中的设置</p>
<p>为了在 MFC 应用程序中能使用 GDI+，必须包含 GDI+头文件、使用 GDI+命名空间。 对 VC08 及之前的版本，还要为项目添加 GDI+链接库。</p>
<p>1) 包含头文件、使用命名空间——在要使用 GDI+的文件（如视图类的头文件或代码 文件）头部包含 GDI+的头文件：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;gdiplus.h&amp;gt;</span></span><br></pre></td></tr></table></figure>
<p>并加上使用 GDI+命名空间的 using 指令（区分大小写，注意首字母大写）：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">Gdiplus</span>;</span><br></pre></td></tr></table></figure>
<p>2) 添加链接库（对 VC08 SP1 及 VC10 不必添加）——在 VS08 及其早期版本中，选 “项目/*属性”菜单项，打开项目的属性页窗口，先选“所有配置”，再选“配置 属性/链接器/输入”项，在右边上部的“附加依赖项”栏的右边，键入 GdiPlus.lib（参见图 14-9）后按“应用”钮，最后按“确定”钮关闭对话框。</p>
<p>（2）GDI+的初始化与清除</p>
<p>为了在 MFC 应用程序中使用采用 C++封装的 GDI+ API，必须在 MFC 项目的应用程序 类 中 ， 调 用 GDI+ 命 名 空 间 中 的 GDI+ 启 动 函 数 GdiplusStartup 和 GDI+ 关 闭 函 数 GdiplusShutdown，来对 GDI+进行初始化（装入动态链接库 Gdiplus.dll，或锁定标志+1）和 清除（卸载动态链接库 Gdiplus.dll，或锁定标志-1）工作。它们一般分别在应用程序类的InitInstance 和 ExitInstance 重载方法中调用。</p>
<p><img src="../img/gdip-编程基础/Image_014.jpg" alt="image"></p>
<p>图 14-9 在项目属性对话框中添加静态链接库</p>
<p>函数 GdiplusStartup 和 GdiplusShutdown，都被定义在 GdiplusInit.h 头文件中：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Status WINAPI GdiplusStartup( <span class="keyword">OUT</span> ULONG_PTR *<span class="keyword">token</span>,</span><br><span class="line"><span class="keyword">const</span> GdiplusStartupInput *<span class="keyword">input</span>, <span class="keyword">OUT</span> GdiplusStartupOutput *output); </span><br><span class="line">void GdiplusShutdown(ULONG_PTR <span class="keyword">token</span>);</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<p>类型 ULONG_PTR，是用无符号长整数表示的指针，被定义在 basetsd.h 头文件中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> _W64 <span class="keyword">unsigned</span> <span class="keyword">long</span> ULONG_PTR;</span><br></pre></td></tr></table></figure>
<p>输出参数 token（权标），供关闭 GDI+的函数使用，所以必须设置为应用程序类的 成员变量（或全局变量，不提倡）。</p>
<p>结构 GdiplusStartupInput 和 GdiplusStartupOutput，都被定义在 GdiplusInit.h 头文件中。</p>
<p>GDI+启动输入结构指针参数 input，一般取默认构造值即可，即（设：无调 试事件回调过程、不抑制背景线程、不抑制外部编解码）：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">input</span> = GdiplusStartupInput(NULL, <span class="literal">FALSE</span>, <span class="literal">FALSE</span>);</span><br></pre></td></tr></table></figure>
<p>GDI+启动输出结构指针参数 output，一般不需要，取为 NULL 即可。 注意，采用 MFC 进行 GDI+ API 编程时，在使用任何 GDI+的功能调用之前，必须先调用 GDI+启动函数 GdiplusStartup 来进行初始化 GDI+的工作；在完成所有的 GDI+功能调用 之后，必须调用 GDI+关闭函数 GdiplusShutdown 来进行清除 GDI+的工作。</p>
<p>（3）过程框图</p>
<p>图 14-10 是使用 MFC 进行 GDI+编程的设置、准备与初始化过程的逻辑框图。</p>
<p><img src="../img/gdip-编程基础/1-10.png" alt=""></p>
<p>图 14-10 GDI+的设置、准备与初始化</p>
<h3 id="1-3-2-编程例子"><a href="#1-3-2-编程例子" class="headerlink" title="1.3.2 编程例子"></a>1.3.2 编程例子</h3><p>下面通过一个简单的例子，来说明如何使用 GDI+进行应用程序开发。</p>
<p>（1）创建和设置</p>
<p>创建一个名为 Gdip 的传统界面 MFC 单文档应用程序项目，在应用程序类和视图类的CPP 代码文件中，包含头文件并使用命名空间：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gdiplus.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Gdiplus;</span><br></pre></td></tr></table></figure>
<p>对 VC08 及之前的版本还需在项目属性中添加链接库 GdiPlus.lib。</p>
<p>（2）初始化与清除</p>
<p>然后再进行 GDI+系统的初始化，这需要在应用程序类 CGdipApp 中声明一个成员变量：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ULONG_PTR m_gdiplusToken<span class="comment">; // ULONG PTR 为 int64 类型 并在该类的初始化函数 CGdipApp::InitInstance()中加入以下代码来对 GDI+进行初始化：</span></span><br><span class="line">GdiplusStartupInput gdiplusStartupInput<span class="comment">; </span></span><br><span class="line">GdiplusStartup(<span class="name">&amp;m_gdiplusToken</span>, <span class="symbol">&amp;gdiplusStartupInput</span>, NULL)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>注意：这两个语句必须加在应用程序类的 InitInstance 函数中的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CWinApp::InitInstance();</span><br></pre></td></tr></table></figure>
<p>语句之前，不然以后会造成视图窗口不能自动重画、程序中不能使用字体等等一系列问题。</p>
<p>还要在 CGdipApp::ExitInstance()中加入以下代码来关闭 GDI+：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GdiplusShutdown(<span class="name">m_gdiplusToken</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>上面的 InitInstance 和 ExitInstance 都是应用程序类的重写型方法。而且，默认时 VC08 SP1 及其以前版本是不会自动生成 ExitInstance 方法代码的（不过 VC10 会自动生成此方法），需 要自己利用属性窗口来添加（不要手工添加）。</p>
<p>（3）绘图</p>
<p>接下来就可以利用 GDI+进行绘图了。下面的代码段是在 OnDraw 函数中画一个带网格 的透明度连续变化的图：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">CGdipView::OnDraw(CDC* pDC) &#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="function">Graphics <span class="title">graph</span><span class="params">(pDC-&amp;gt;m_hDC)</span></span>; <span class="comment">// 创建图形对象</span></span><br><span class="line">    <span class="function">Pen <span class="title">bluePen</span><span class="params">(Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>)</span>)</span>; <span class="comment">// 创建蓝色笔</span></span><br><span class="line">    <span class="function">Pen <span class="title">redPen</span><span class="params">(Color(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>)</span>)</span>; <span class="comment">// 创建红色笔</span></span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">255</span>; <span class="comment">// y 的初值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &amp;lt; <span class="number">256</span>; x += <span class="number">5</span>) &#123; <span class="comment">// 绘制红蓝网线</span></span><br><span class="line">        graph.DrawLine(&amp;bluePen, <span class="number">0</span>, y, x, <span class="number">0</span>);</span><br><span class="line">        graph.DrawLine(&amp;redPen, <span class="number">255</span>, x, y, <span class="number">255</span>);</span><br><span class="line">        y -= <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 画一组绿色透明度垂直渐变的水平线（填满正方形）</span></span><br><span class="line">    <span class="keyword">for</span> (y = <span class="number">0</span>; y &amp;lt; <span class="number">256</span>; y++) &#123;</span><br><span class="line">        <span class="function">Pen <span class="title">pen</span><span class="params">(Color(y, <span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>)</span>)</span>; <span class="comment">// α 随 y 变的绿色笔</span></span><br><span class="line">    graph.DrawLine(&amp;pen, <span class="number">0</span>, y, <span class="number">255</span>, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 画一组品红色透明度水平渐变的垂直线（填满扁矩形）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &amp;lt; <span class="number">256</span>; x++) &#123;</span><br><span class="line">        <span class="function">Pen <span class="title">pen</span><span class="params">(Color(x, <span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>)</span>)</span>; <span class="comment">// α 随 x 变的品红色笔</span></span><br><span class="line">        graph.DrawLine(&amp;pen, x, <span class="number">100</span>, x, <span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行的结果如图 14-11 所示。其中，左图为第一个循环所绘制的结果、中图为前两个循 环所绘制的结果、右图为全部三个循环所绘制的结果。</p>
<p><img src="../img/gdip-编程基础/Image_017.jpg" alt="image"></p>
<p><img src="../img/gdip-编程基础/Image_018.jpg" alt="image"></p>
<p><img src="../img/gdip-编程基础/Image_019.jpg" alt="image"></p>
<p>图 14-11 透明度的连续变化</p>
<h3 id="1-3-3-new-问题"><a href="#1-3-3-new-问题" class="headerlink" title="1.3.3 new 问题"></a>1.3.3 new 问题</h3><p>在 VC08（包括 SP1）中使用 GDI+时，不能用 new 来动态创建 GDI+对象。解决办法有 如下两种：</p>
<p>（1）修改 GdiplusBase 类</p>
<p>打开（默认）位于“C:\Program Files\Microsoft SDKs\Windows\v6.0A\ Include\”目录中 的 Gdiplus Base.h 头文件，并注释掉里面 Gdiplus Base 类的内容（该类其实只含 new、new[]、 delete 和 delete[]这四个运算符的重载），使其成为一个空类（但不要删除整个类）。</p>
<p>为了不修改原始安装目录中的 Gdiplus Base.h 头文件，可以：</p>
<ul>
<li><p>将该头文件复制到你的项目目录中。</p>
</li>
<li><p>注释掉该头文件里面 Gdiplus Base 类的内容（保留类定义）。</p>
</li>
<li><p>在项目中所有的#include &lt;gdiplus.h&gt;语句之前，包含”Gdiplus Base.h”头文件，形如：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"gdiplusBase.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> &amp;lt;gdiplus.h&amp;gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>则编译系统会优先包含项目目录中的 gdiplus Base.h 头文件，从而屏蔽掉原来位于 平台 SDK 的 Include 目录中的同名头文件。</p>
</li>
</ul>
<p>（2）用&amp;代替 new</p>
<p>也可以在有些使用 new 的地方改用&amp;，例如将代码 Pen <em>pPen = <strong>new</strong> Pen(Color::Red); 改 为 Pen </em>pPen = <strong>&amp;</strong>Pen(Color::Red);。</p>
<h2 id="1-4-几何辅助类"><a href="#1-4-几何辅助类" class="headerlink" title="1.4 几何辅助类"></a>1.4 几何辅助类</h2><p>与 GDI 的类似，在 GDI+ API 中也定义了许多绘图的辅助类，常用的有点、大小和矩形 等几何类。它们都是没有基类的独立类，被定义在头文件 GdiplusTypes.h 中。与 GDI 不同 的是，在 GDI+中新增加了浮点型的几何类。</p>
<p>浮点数版的几何对象和绘图方法，是 GDI+新增的功能，这些在各种工程技术领域都非 常有用。因为一般的实际图形设计，都是基于实数坐标的。包括机械（../轮船/飞机 等）、建筑（../道路/堤坝等）和图形动画设计（../../轨迹等）等设 计，都必须使用浮点参数和坐标系。</p>
<p>下面对 GDI+的几何辅助类，逐个进行简单的介绍。</p>
<h3 id="1-4-1-Point-F-（点）"><a href="#1-4-1-Point-F-（点）" class="headerlink" title="1.4.1 Point[F]（点）"></a>1.4.1 Point[F]（点）</h3><p>GDI+中，有两种类型的点：整数点（对应于 Point 类，与 GDI 的 MFC 类 CPoint 类似） 和浮点数点（对应于 PointF 类），下面分别加以介绍。</p>
<p>（1）整数点类 Point</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Point</span> </span></span><br><span class="line"><span class="class">&#123; </span></span><br><span class="line"><span class="class">public:</span></span><br><span class="line"><span class="class">    <span class="type">Point</span>() &#123;<span class="type">X</span> = <span class="type">Y</span> = 0;&#125;</span></span><br><span class="line"><span class="class">    <span class="type">Point</span>(<span class="title">const</span> <span class="type">Point</span> &amp;<span class="title">point</span>) &#123;<span class="type">X</span> = point.<span class="type">X</span>; <span class="type">Y</span> = point.<span class="type">Y</span>;&#125; </span></span><br><span class="line"><span class="class">    <span class="type">Point</span>(<span class="title">const</span> <span class="type">Size</span> &amp;<span class="title">size</span>) &#123;<span class="type">X</span> = size.<span class="type">Width</span>; <span class="type">Y</span> = size. <span class="type">Height</span>;&#125; </span></span><br><span class="line"><span class="class">    <span class="type">Point</span>(<span class="type">INT</span> <span class="title">x</span>, <span class="type">INT</span> <span class="title">y</span>) &#123;<span class="type">X</span> = x; <span class="type">Y</span> = y;&#125;</span></span><br><span class="line"><span class="class">    <span class="type">Point</span> operator+(<span class="title">const</span> <span class="type">Point</span>&amp; <span class="title">point</span>) const &#123;return <span class="type">Point</span>(<span class="type">X</span> + <span class="title">point</span>.<span class="type">X</span>, <span class="type">Y</span> + <span class="title">point</span>.<span class="type">Y</span>);&#125;</span></span><br><span class="line"><span class="class">    <span class="type">Point</span> operator-(<span class="title">const</span> <span class="type">Point</span>&amp; <span class="title">point</span>) const &#123;return <span class="type">Point</span>(<span class="type">X</span> - <span class="title">point</span>.<span class="type">X</span>, <span class="type">Y</span> - <span class="title">point</span>.<span class="type">Y</span>);&#125; </span></span><br><span class="line"><span class="class">    <span class="type">BOOL</span> <span class="type">Equals</span>(<span class="title">const</span> <span class="type">Point</span>&amp; <span class="title">point</span>) &#123;return (<span class="type">X</span> == <span class="title">point</span>.<span class="type">X</span>) &amp;&amp; (<span class="type">Y</span> == <span class="title">point</span>.<span class="type">Y</span>);&#125;</span></span><br><span class="line"><span class="class">public:</span></span><br><span class="line"><span class="class">    <span class="type">INT</span> <span class="type">X</span>; <span class="type">INT</span> <span class="type">Y</span>; // 大写 <span class="type">X</span>、<span class="type">Y</span></span></span><br><span class="line"><span class="class">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>其中：typedef int INT; 为 4 字节有符号整数（windef.h）。 注意，GDI+的点与 GDI 的区别：POINT 和 CPoint 采用小写的 x、y。</p>
<p>（2）浮点数点类 PointF</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> PointF </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    PointF() &#123;X = Y = <span class="number">0.</span>f;&#125;</span><br><span class="line">    PointF(<span class="keyword">REAL</span> x, <span class="keyword">REAL</span> y) &#123;X = x; Y = y;&#125;</span><br><span class="line">    ... // 与整数版的类似</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">REAL</span> X; <span class="keyword">REAL</span> Y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中：typedef float REAL; 为 4 字节浮点数（GdiplusTypes.h）。</p>
<h3 id="1-4-2-Size-F-（大小）"><a href="#1-4-2-Size-F-（大小）" class="headerlink" title="1.4.2 Size[F]（大小）"></a>1.4.2 Size[F]（大小）</h3><p>GDI+中，也有两种类型的大小（尺寸）：整数大小（对应于 Size 类，与 GDI 的 MFC 类 CSize 类似）和浮点数大小（对应于 SizeF 类）。下面分别加以介绍：</p>
<p>（1）整数大小类 Size：</p>
<p>class Size<br>{<br>public:<br>    Size() {Width = Height = 0;}<br>    Size(INT width, INT height) {Width = width; Height = height;}<br>    …<br>public:<br>    INT Width;<br>    INT Height; // 宽和高，不再是 cx 和 cy<br>};</p>
<p>注意，这里的大小与 GDI 的区别：SIZE 和 CSize 的分量成员为 cx 和 cy，不是宽和高。</p>
<p>（2）浮点数大小类 SizeF：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> SizeF </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SizeF() &#123;Width = Height = <span class="number">0.</span>f;&#125;</span><br><span class="line">    SizeF(<span class="keyword">REAL</span> width, <span class="keyword">REAL</span> height) &#123;Width = width; Height = height;&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">REAL</span> Width; <span class="keyword">REAL</span> Height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-3-Rect-F-（矩形）"><a href="#1-4-3-Rect-F-（矩形）" class="headerlink" title="1.4.3 Rect[F]（矩形）"></a>1.4.3 Rect[F]（矩形）</h3><p>GDI+中，也有两种类型的矩形：整数矩形（对应于 Rect 类，与 GDI 的 MFC 类 CRect 类似）和浮点数矩形（对应于 RectF 类），下面分别加以介绍。</p>
<p>（1）整数矩形类 Rect：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Rect() &#123;X = Y = Width = Height = <span class="number">0</span>;&#125;</span><br><span class="line">    Rect(<span class="keyword">INT</span> x, <span class="keyword">INT</span> y, <span class="keyword">INT</span> width, <span class="keyword">INT</span> height);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">INT</span> GetLeft() <span class="keyword">const</span> &#123;<span class="keyword">return</span> X;&#125; <span class="keyword">INT</span> GetTop() <span class="keyword">const</span> &#123;<span class="keyword">return</span> Y;&#125;</span><br><span class="line">    <span class="keyword">INT</span> GetRight() <span class="keyword">const</span> &#123;<span class="keyword">return</span> X+Width;&#125; <span class="keyword">INT</span> GetBottom() <span class="keyword">const</span> &#123;<span class="keyword">return</span> Y+Height;&#125;</span><br><span class="line">    <span class="keyword">BOOL</span> IsEmptyArea() <span class="keyword">const</span>&#123;<span class="keyword">return</span> (Width &amp;lt;= <span class="number">0</span>) || (Height &amp;lt;= <span class="number">0</span>);&#125; <span class="keyword">BOOL</span> Equals(<span class="keyword">const</span> Rect &amp; rect) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">BOOL</span> Contains(<span class="keyword">INT</span> x, <span class="keyword">INT</span> y) <span class="keyword">const</span>; <span class="keyword">BOOL</span> **Contains**(<span class="keyword">const</span> Point&amp; pt) <span class="keyword">const</span>; <span class="keyword">BOOL</span> Contains(Rect&amp; rect) <span class="keyword">const</span>;</span><br><span class="line">    ...</span><br><span class="line">    VOID Offset(<span class="keyword">const</span> Point&amp; point); VOID Offset(<span class="keyword">INT</span> dx, <span class="keyword">INT</span> dy);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">INT</span> X; <span class="keyword">INT</span> Y; <span class="comment">// 大写的 X 和 Y（为矩形左上角的坐标），不再是 left 和 top </span></span><br><span class="line">    <span class="keyword">INT</span> Width; </span><br><span class="line">    <span class="keyword">INT</span> Height; <span class="comment">// 宽和高，不再是 right 和 bottom</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，这里的矩形与 GDI 的区别：RECT 和 CRect 的分量成员是左、顶、右、底而不 是 X、Y、宽、高。虽然 Rect 中的(X, Y)等价于 RECT 的(left, top)，但是 Rect 中的(Width, Height) 却不同于 RECT 的(right, bottom)。</p>
<p>（2）浮点数矩形类 RectF：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> RectF </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RectF() &#123;X = Y = Width = Height = <span class="number">0.</span>f;&#125;</span><br><span class="line">    RectF(<span class="keyword">REAL</span> x, <span class="keyword">REAL</span> y, <span class="keyword">REAL</span> width, <span class="keyword">REAL</span> height);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">REAL</span> X; </span><br><span class="line">    <span class="keyword">REAL</span> Y;</span><br><span class="line">    <span class="keyword">REAL</span> Width; </span><br><span class="line">    <span class="keyword">REAL</span> Height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 GDI 的 MFC 封装中，除了定义有点、大小和矩形的类外，还保留了对应的 API 结构 POINT、SIZE 和 RECT，主要是考虑运行效率及与底层 GDI API 的兼容。</p>
<p>比较可知，GDI 和 GDI+都有对应的几何类，不过 GDI+没有对应的结构（但有新增加 的浮点数版类），而 GDI 则没有对应的浮点数版类（但却有对应的结构）。</p>
<h2 id="1-5-颜色"><a href="#1-5-颜色" class="headerlink" title="1.5 颜色"></a>1.5 颜色</h2><p>与 GDI 相比，GDI+的颜色新增了一个透明分量，并且定义了颜色类 Color。</p>
<h3 id="1-5-1-颜色类型-ARGB"><a href="#1-5-1-颜色类型-ARGB" class="headerlink" title="1.5.1 颜色类型 ARGB"></a>1.5.1 颜色类型 ARGB</h3><p>GDI+中的颜色，与 GDI 中的颜色的最大不同，是增加了一个字节（8 位）的透明分量 alpha（α ），用来表示颜色的不透明度：0 透明（看不见前景色，只有背景色）~255 不透明（看不见背景色，只有前景色，相当于覆盖和拷贝）。背景色指屏幕窗口中原有图形的颜色， 前景色指将要绘制图形的颜色。</p>
<p>因此，GDI+中的颜色一般都是用四个字节表示（Intel CPU 中，多字节整数的低位在前）：</p>
<ul>
<li><p>整数序（高位→低位）：</p>
<p><img src="../img/gdip-编程基础/1-5-1-1.png" alt=""></p>
</li>
<li><p>字节序（低字节→高字节）：</p>
<p><img src="../img/gdip-编程基础/1-5-1-2.png" alt=""></p>
</li>
</ul>
<p>在 GDI 中没有专门的颜色类，只有一个颜色类型 COLORREF，也定义为： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> DWORD COLORREF; <span class="comment">// 0x00bbggrr (windef.h)</span></span><br></pre></td></tr></table></figure>
<p>和一个生成颜色的宏：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">COLORREF</span> RGB( <span class="keyword">BYT </span>E <span class="keyword">bRed, </span><span class="keyword">BYTE </span><span class="keyword">bGreen, </span><span class="keyword">BYT </span>E <span class="keyword">bBlue);</span></span><br></pre></td></tr></table></figure>
<p>其中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE; <span class="comment">// 单字节无符号字符整数</span></span><br></pre></td></tr></table></figure>
<p>在 GDI+中，也将颜色数据定义为无符号 4 字节长整数类型 DWORD，但是改名为 ARGB： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> DWORD ARGB; <span class="comment">// gdipluspixelformats.h</span></span><br></pre></td></tr></table></figure>
<h3 id="1-5-2-颜色类-Color"><a href="#1-5-2-颜色类-Color" class="headerlink" title="1.5.2 颜色类 Color"></a>1.5.2 颜色类 Color</h3><p>而且 GDI+中还定义了专门的 Color 类，不仅包含了此颜色数据，而且还有多个构造函 数和其他辅助方法、枚举和常量。</p>
<p>Color 类的构造函数中，最常用的是：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Color( <span class="keyword">BYTE</span> a, <span class="keyword">BYTE</span> r, BYT E g, <span class="keyword">BYTE</span> b); <span class="comment">// a 为 alpha 分量α 但也有一个默认构造函数：</span></span><br><span class="line">Color( <span class="keyword">VOID</span>); <span class="comment">// 不透明黑色，相当于 Color(255, 0, 0, 0);</span></span><br></pre></td></tr></table></figure>
<p>还有一个与 GDI 兼容的构造函数：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Color</span>( <span class="keyword">BYTE </span>r, <span class="keyword">BYTE </span>g, <span class="keyword">BYTE </span><span class="keyword">b); </span>// 不透明色，相当于 Color(<span class="number">255</span>, r, g, <span class="keyword">b);</span></span><br></pre></td></tr></table></figure>
<p>你也可以直接用含颜色数据的 4 字节无符号整数，来构造 Color 类的对象：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Color<span class="comment">( ARGB argb)</span>; <span class="comment">// 相当于 Color(a, r, g, b);</span></span><br></pre></td></tr></table></figure>
<p>该整数可以由 Color 类的静态方法 MakeARGB 或动态方法 GetValue 获得：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static ARGB MakeARGB( <span class="keyword">BYT </span>E a, <span class="keyword">BYTE </span>r, <span class="keyword">BYTE </span>g, <span class="keyword">BYTE </span><span class="keyword">b);</span></span><br><span class="line"><span class="keyword">ARGB </span>GetValue(VOID)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>你还也可以用 Color 类的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">COLORREF <span class="title">ToCOLORREF</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>将 Color 对象中的颜色，转换为 GDI 的颜色类型。</p>
<p>Color 类还提供了各个颜色分量的获取方法及其简化版：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BYTE <span class="title">GetAlpha</span><span class="params">()</span> <span class="keyword">const</span></span>; </span><br><span class="line"><span class="function">BYTE <span class="title">GetA</span><span class="params">()</span> <span class="keyword">const</span></span>; </span><br><span class="line"><span class="function">BYTE <span class="title">GetRed</span><span class="params">()</span> <span class="keyword">const</span></span>; </span><br><span class="line"><span class="function">BYTE <span class="title">GetR</span><span class="params">()</span> <span class="keyword">const</span></span>; </span><br><span class="line"><span class="function">BYTE <span class="title">GetGreen</span><span class="params">()</span> <span class="keyword">const</span></span>; </span><br><span class="line"><span class="function">BYTE <span class="title">GetG</span><span class="params">()</span> <span class="keyword">const</span></span>; </span><br><span class="line"><span class="function">BYTE <span class="title">GetBlue</span><span class="params">()</span> <span class="keyword">const</span></span>; </span><br><span class="line"><span class="function">BYTE <span class="title">GetB</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>你也可以先用宏：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BYTE <span class="title">GetRValue</span><span class="params">(DWORD rgb)</span></span>; <span class="comment">// COLORREF rgb </span></span><br><span class="line"><span class="function">BYTE <span class="title">GetGValue</span><span class="params">(DWORD rgb)</span></span>; <span class="comment">// COLORREF rgb </span></span><br><span class="line"><span class="function">BYTE <span class="title">GetBValue</span><span class="params">(DWORD rgb)</span></span>; <span class="comment">// COLORREF rgb</span></span><br></pre></td></tr></table></figure>
<p>获取 COLORREF 的 R、G、B 值，然后再用这些值调用 Color 类的构造函数来创建 Color 对象。例如：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">COLORREF crCol = colDlg.GetColor<span class="comment">()</span>; </span><br><span class="line">BYTE r = GetRValue<span class="comment">(crCol)</span>,</span><br><span class="line">     g = GetGValue<span class="comment">(crCol)</span>, </span><br><span class="line">     b = GetBValue<span class="comment">(crCol)</span>;</span><br><span class="line">Color col<span class="comment">(r, g, b)</span>; <span class="comment">// Color col(crCol | (255&lt;&lt;24));</span></span><br></pre></td></tr></table></figure>
<h3 id="1-5-3-颜色枚举常量"><a href="#1-5-3-颜色枚举常量" class="headerlink" title="1.5.3 颜色枚举常量"></a>1.5.3 颜色枚举常量</h3><p>GDI+在颜色头文件 GdiplusColor.h 中，定义了 141 个公用颜色枚举常量，都是对应颜色 的英文单词。可以用 Color 类直接访问，例如：Color ::Red。</p>
<p>下面是部分颜色枚举常量（按字母顺序排列）：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">    <span class="comment">// Common color constants 通用颜色常量</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        AliceBlue = <span class="number">0</span>xFFF0F8FF, <span class="comment">// 艾丽丝蓝</span></span><br><span class="line">        AntiqueWhite = <span class="number">0</span>xFFFAEBD7, <span class="comment">// 古董白</span></span><br><span class="line">        Aqua = <span class="number">0</span>xFF00FFFF, <span class="comment">// 水绿</span></span><br><span class="line">        Aquamarine = <span class="number">0</span>xFF7FFFD4, <span class="comment">// 碧绿</span></span><br><span class="line">        Azure = <span class="number">0</span>xFFF0FFFF, <span class="comment">// 天蓝</span></span><br><span class="line">        Beige = <span class="number">0</span>xFFF5F5DC, <span class="comment">// 米色</span></span><br><span class="line">        Bisque = <span class="number">0</span>xFFFFE4C4, <span class="comment">// 汤黄</span></span><br><span class="line">        Black = <span class="number">0</span>xFF000000, <span class="comment">// 黑</span></span><br><span class="line">        BlanchedAlmond = <span class="number">0</span>xFFFFEBCD, <span class="comment">// 布兰奇杏黄</span></span><br><span class="line">        Blue = <span class="number">0</span>xFF0000FF, <span class="comment">// 蓝</span></span><br><span class="line">        BlueViolet = <span class="number">0</span>xFF8A2BE2, <span class="comment">// 蓝紫</span></span><br><span class="line">        Brown = <span class="number">0</span>xFFA52A2A, <span class="comment">// 棕褐</span></span><br><span class="line">        ...</span><br><span class="line">        Tan = <span class="number">0</span>xFFD2B48C, <span class="comment">// 茶色</span></span><br><span class="line">        Teal = <span class="number">0</span>xFF008080, <span class="comment">// 水鸭青</span></span><br><span class="line">        Thistle = <span class="number">0</span>xFFD8BFD8, <span class="comment">// 蓟色</span></span><br><span class="line">        Tomato = <span class="number">0</span>xFFFF6347, <span class="comment">// 番茄红</span></span><br><span class="line">        Transparent = <span class="number">0</span>x00FFFFFF, <span class="comment">// 透明</span></span><br><span class="line">        Turquoise = <span class="number">0</span>xFF40E0D0, <span class="comment">// 宝石绿</span></span><br><span class="line">        Violet = <span class="number">0</span>xFFEE82EE, <span class="comment">// 紫罗兰</span></span><br><span class="line">        Wheat = <span class="number">0</span>xFFF5DEB3, <span class="comment">// 小麦色</span></span><br><span class="line">        White = <span class="number">0</span>xFFFFFFFF, <span class="comment">// 白</span></span><br><span class="line">        WhiteSmoke = <span class="number">0</span>xFFF5F5F5, <span class="comment">// 烟白</span></span><br><span class="line">        Yellow = <span class="number">0</span>xFFFFFF00, <span class="comment">// 黄</span></span><br><span class="line">        YellowGreen = <span class="number">0</span>xFF9ACD32 <span class="comment">// 黄绿</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>图 14-12 是各种颜色枚举字符常量（包括中文译名）所对应的色块表（按字母顺序排列）。</p>
<h2 id="1-6-图形类-Graphics"><a href="#1-6-图形类-Graphics" class="headerlink" title="1.6 图形类 Graphics"></a>1.6 图形类 Graphics</h2><p>与 GDI 的 MFC 类 CDC 类似，GDI+的绘图功能主要由图形类 Graphics 承担。</p>
<p>图形类 Graphics 是 GDI+的核心，它提供绘制图形、图像和文本的各种方法（似 GDI 中的 CDC 类），还可以存储显示设备和被画项目的属性（到图元文件）。Graphics 类及其方 法都被定义在头文件 Gdiplusgraphics.h 中。</p>
<p><img src="../img/gdip-编程基础/Image_020.jpg" alt="image"></p>
<p><img src="../img/gdip-编程基础/Image_021.jpg" alt="image"></p>
<p>图 14-12 颜色枚举常量</p>
<h3 id="1-6-1-构造函数"><a href="#1-6-1-构造函数" class="headerlink" title="1.6.1 构造函数"></a>1.6.1 构造函数</h3><p>Graphics 类的构造函数有如下 4 种：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Graphics<span class="comment">(Image* image)</span>; <span class="comment">// 用于绘制图像</span></span><br><span class="line">Graphics<span class="comment">(HDC hdc)</span>; <span class="comment">// 用于在当前窗口中绘图</span></span><br><span class="line">Graphics<span class="comment">(HDC hdc, HANDLE hdevice)</span>; <span class="comment">// 用于在制定设备上绘制图形</span></span><br><span class="line">Graphics<span class="comment">(HWND hwnd, BOOL icm = FALSE)</span>; <span class="comment">// 用于在指定窗口中绘图</span></span><br></pre></td></tr></table></figure>
<p>其中，最常用的是第二种——在当前视图窗口中绘图的图形类构造函数。</p>
<p>注意，该构造函数的输入参数，是设备上下文的句柄，而不是 CDC 类对象的指针。一 般可以由 CDC 对象得到（因 CDC 类含有公用数据成员 HDC m_hDC;）：</p>
<ul>
<li><p>在 OnDraw 函数中，利用输入参数 CDC *pDC，就可直接得到 DC 句柄。例如：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Graphics graph(pDC-<span class="meta">&amp;gt;m_hDC);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在视图类的其他函数中，可先利用 GetDC 函数得到 CDC 指针，然后再利用它去获 取 DC 的句柄。例如：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Graphics graph<span class="comment">(GetDC()</span>-&amp;<span class="keyword">gt</span>;m_hDC);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>也可以使用 Graphics 类的另一个构造函数 <code>Graphics(HWND hwnd, BOOL icm = FALSE);</code>，利用视图类的窗口句柄成员来构造 Graphics 对象。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Graphics <span class="title">graph</span><span class="params">(<span class="keyword">this</span>-&amp;gt;m_hWnd)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="1-6-2-状态枚举-status"><a href="#1-6-2-状态枚举-status" class="headerlink" title="1.6.2 状态枚举 status"></a>1.6.2 状态枚举 status</h3><p>在图形类 Graphics 中，封装了各种绘图方法。每种绘图方法被调用后，都会返回一种 叫做 status 的枚举值，反映该方法是否被正确执行，0 表示正确，其他大于 0 的值为错误代 码（GdiplusTypes.h）：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">enum</span> &#123; // 状态枚举（含 22 个枚举值）</span></span><br><span class="line">    Ok = <span class="number">0</span>,</span><br><span class="line">    GenericError = <span class="number">1</span>,</span><br><span class="line">    InvalidParameter = <span class="number">2</span>,</span><br><span class="line">    OutOfMemory = <span class="number">3</span>,</span><br><span class="line">    ...</span><br><span class="line">    PropertyNotSupported = <span class="number">20</span>,</span><br><span class="line">    ProfileNotFound = <span class="number">21</span></span><br><span class="line">&#125; Status;</span><br></pre></td></tr></table></figure>
<p>GDI+的绘图功能被封装在图形类 Graphics 中，下面介绍其中的常用绘图方法。先讲绘 制线型图的方法，再讲绘制填充图的方法，最后讲绘制文字的方法。</p>
<h3 id="1-6-3-画线型图的方法"><a href="#1-6-3-画线型图的方法" class="headerlink" title="1.6.3 画线型图的方法"></a>1.6.3 画线型图的方法</h3><p>GDI+中绘制线型图形的方法与 GDI 的类似，也包括绘直线、矩形、椭圆和多边形等， 但是 GDI+增加了浮点版本和若干新功能。GDI+的画线函数都是 Graphics 类的方法，而且所 有方法的名称都是以 Draw 开头。</p>
<p>（1）画直线[折线]DrawLine[s]</p>
<p>在 GDI+中定义了 6 种绘制直线和折线的方法，前三个为整数版，后三个为对应的浮点 数版：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DrawLine</span><span class="params">(<span class="keyword">const</span> Pen* pen, INT x1, INT y1, INT x2, INT y2)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">DrawLine</span><span class="params">(<span class="keyword">const</span> Pen* pen, <span class="keyword">const</span> Point&amp; pt1, <span class="keyword">const</span> Point&amp; pt2)</span></span>; </span><br><span class="line"><span class="function">Status <span class="title">DrawLines</span><span class="params">(<span class="keyword">const</span> Pen* pen, <span class="keyword">const</span> Point* points, INT count)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">DrawLine</span><span class="params">(<span class="keyword">const</span> Pen* pen, REAL x1, REAL y1, REAL x2, REAL y2)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">DrawLine</span><span class="params">(<span class="keyword">const</span> Pen* pen, <span class="keyword">const</span> PointF&amp; pt1, <span class="keyword">const</span> PointF&amp; pt2)</span></span>; </span><br><span class="line"><span class="function">Status <span class="title">DrawLines</span><span class="params">(<span class="keyword">const</span> Pen* pen, <span class="keyword">const</span> PointF* points, INT count)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><p>DrawLine——画直线（4 个重载），参数 pen 为画直线所用的笔、(x1, y1)和 pt1 为 直线的起点、(x2, y2)和 pt2 为直线的终点。GDI 的相应函数为 MoveTo 和 LineTo。</p>
</li>
<li><p>DrawLines——画折线（一串相互连接的直线段）（2 个重载），参数 points 为点数 组、count 为数组中点的数目。GDI 的相应函数为 Polyline。</p>
</li>
</ul>
<p>（2）画矩形[组] DrawRectangle[s]</p>
<p>在 GDI+中也定义了 6 种绘制矩形和矩形组的方法，也是前三个为整数版，后三个为对 应的浮点数版：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Status</span> DrawRectangle(const Pen* pen, const Rect&amp; rect);</span><br><span class="line"><span class="keyword">Status</span> DrawRectangle(const Pen* pen, <span class="built_in">INT</span> x, <span class="built_in">INT</span> y, <span class="built_in">INT</span> width, <span class="built_in">INT</span> height); </span><br><span class="line"><span class="keyword">Status</span> DrawRectangles(const Pen* pen, const Rect* rects, <span class="built_in">INT</span> <span class="built_in">count</span>);</span><br><span class="line"><span class="keyword">Status</span> DrawRectangle(const Pen* pen, const RectF&amp; rect);</span><br><span class="line"><span class="keyword">Status</span> DrawRectangle(const Pen* pen, <span class="keyword">REAL</span> x, <span class="keyword">REAL</span> y, <span class="keyword">REAL</span> width, <span class="keyword">REAL</span> height); </span><br><span class="line"><span class="keyword">Status</span> DrawRectangles(const Pen* pen, const RectF* rects, <span class="built_in">INT</span> <span class="built_in">count</span>);</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><p>DrawRectangle——画单个矩形（4 个重载），参数 pen 为画矩形所用的笔、rect 为 矩形区域、(x, y)为矩形的左上角、(width, height)为矩形的大小（宽，高）。与 GDI 的对应函数 BOOL Rectangle( int x1, int y1, int x2, int y2);的区别主要是 GDI+的第 2 个和第 4 个画矩形方法的后两个输入参数，不再是 GDI 中的矩形右下角的坐标， 而改成矩形的宽和高了。</p>
</li>
<li><p>DrawRectangles——画多个矩形（2 个重载），参数 rects 为矩形数组、count 为数组 中矩形的数目。GDI 中没有同时绘制一个矩形数组的函数。</p>
</li>
</ul>
<p>（3）[椭]圆 DrawEllipse</p>
<p>GDI+中有 4 个重载的绘制椭圆的方法，如果输入参数所确定的外接矩形的宽高相等， 则画圆。也是前两个为整数版，后两个为对应的浮点数版：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Status DrawEllipse(<span class="keyword">const</span> Pen* pen, <span class="keyword">const</span> Rect&amp; <span class="built_in">rect</span>);</span><br><span class="line">Status DrawEllipse(<span class="keyword">const</span> Pen* pen, INT x, INT y, INT <span class="built_in">width</span>, INT <span class="built_in">height</span>) Status DrawEllipse(<span class="keyword">const</span> Pen* pen, <span class="keyword">const</span> RectF&amp; <span class="built_in">rect</span>);</span><br><span class="line">Status DrawEllipse(<span class="keyword">const</span> Pen* pen, REAL x, REAL y, REAL <span class="built_in">width</span>, REAL <span class="built_in">height</span>);</span><br></pre></td></tr></table></figure>
<p>这些方法的功能，与 GDI 中的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">Ellipse</span><span class="params">( <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2 )</span></span>;</span><br></pre></td></tr></table></figure>
<p>图 14-13 画弧方法的输入参数</p>
<p>类似，但是同样要注意 GDI+的 DrawEllipse 方法与 GDI 的 Ellipse 函数的主要区别（与画矩 形的方法与函数类似），是上面的以坐标为参数的第 2、4 个 GDI+画椭圆方法的后两个输入 参数，也是矩形的宽高而不再是矩形的右下角坐标了。</p>
<p>（4）画[椭]圆弧 DrawArc</p>
<p>GDI+中也有 4 个重载的绘制椭圆弧的方法，如果输入参数所确定的外接矩形的宽高相 等，则画圆弧。也是前两个为整数版，后两个为对应的浮点数版。</p>
<p><img src="../img/gdip-编程基础/Image_022.jpg" alt="image"></p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Status</span> DrawArc(const Pen* pen, <span class="built_in">INT</span> x, <span class="built_in">INT</span> y, <span class="built_in">INT</span> width, <span class="built_in">INT</span> height, <span class="keyword">REAL</span> startAngle, <span class="keyword">REAL</span> sweepAngle);</span><br><span class="line"><span class="keyword">Status</span> DrawArc(const Pen* pen, const Rect&amp; rect, <span class="keyword">REAL</span> startAngle, <span class="keyword">REAL</span> sweepAngle);</span><br><span class="line"><span class="keyword">Status</span> DrawArc(const Pen* pen, <span class="keyword">REAL</span> x, <span class="keyword">REAL</span> y, <span class="keyword">REAL</span> width, <span class="keyword">REAL</span> height, <span class="keyword">REAL</span> startAngle, <span class="keyword">REAL</span> sweepAngle);</span><br><span class="line"><span class="keyword">Status</span> DrawArc(const Pen* pen, const RectF&amp; rect, <span class="keyword">REAL</span> startAngle, <span class="keyword">REAL</span> sweepAngle);</span><br></pre></td></tr></table></figure>
<p>注意，角度的单位是度（不是弧度，C++的三角函数 采用的是弧度单位），而且都必须是实数。零度角为 x 轴 方向，顺时针方向为正（这与数学上反时针方向为正刚好相反），参见图 14-13。</p>
<p>（5）画多边形 DrawPolygon</p>
<p>GDI+中有 2 个重载的绘制多边形的方法，前一个为整数版，后一个为对应的浮点数版：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DrawPolygon</span><span class="params">(<span class="keyword">const</span> Pen* pen, <span class="keyword">const</span> Point* points, INT count)</span></span>; </span><br><span class="line"><span class="function">Status <span class="title">DrawPolygon</span><span class="params">(<span class="keyword">const</span> Pen* pen, <span class="keyword">const</span> PointF* points, INT count)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，各参数的含义同画折线方法 DrawLines 的，只是 DrawPolygon 方法会将点数组中的起点和终点连接起来，形成一个封闭的多边形区域。 该方法的功能与 GDI 的 Polygon 函数相同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">Polygon</span><span class="params">( LPPOINT lpPoints, <span class="keyword">int</span> nCount )</span></span>;</span><br></pre></td></tr></table></figure>
<p>注意：GDI+中没有提供与 GDI 函数 RoundRect（圆角矩形）和 Chord（弓弦）具有类 似功能的绘图方法，但可以利用矩形+椭圆和弧+直线等方法来自己实现。</p>
<h3 id="1-6-4-画填充图的方法"><a href="#1-6-4-画填充图的方法" class="headerlink" title="1.6.4 画填充图的方法"></a>1.6.4 画填充图的方法</h3><p>在 GDI 中，任何画封闭区域的性状图绘制函数（如矩形、圆角矩形、[椭]圆、弓弦和多 边形等），都可以画填充图，因为它们总是在用当前笔画指定边框的同时，也用当前刷子填 充内部区域。</p>
<p>而 GDI+的画线方法就没有这个功能，因为在 GDI+是无状态的，没有当前笔和刷的概 念。为了完成与这些 GDI 函数类似的功能，在 GDI+中，你得分两步来做：先用填充方法填 充区域内部，再用画线方法绘制边框。</p>
<p>在 GDI+中画填充图，不需像 GDI 那样得先将刷子选入 DC，而是与 GDI+画线状图的 方法类似，将刷子作为画填充图方法的第一个输入参数。注意，GDI+中的画填充图的方法 都以 Fill 开头。</p>
<p>（1） 画填充矩形[组]FillRectangle[s]</p>
<p>GDI+中有 6 个重载的绘制填充矩形[组]的方法，前 3 个为整数版，后 3 个为对应的浮点 数版：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Status FillRectangle(const <span class="keyword">Brush* </span><span class="keyword">brush, </span>const Rect&amp; rect)<span class="comment">;</span></span><br><span class="line">Status FillRectangle(const <span class="keyword">Brush* </span><span class="keyword">brush, </span>INT x, INT y, INT width, INT height)<span class="comment">; </span></span><br><span class="line">Status FillRectangles(const <span class="keyword">Brush* </span><span class="keyword">brush, </span>const Rect* rects, INT <span class="built_in">count</span>)<span class="comment">;</span></span><br><span class="line">Status FillRectangle(const <span class="keyword">Brush* </span><span class="keyword">brush, </span>const RectF&amp; rect)<span class="comment">;</span></span><br><span class="line">Status FillRectangle(const <span class="keyword">Brush* </span><span class="keyword">brush, </span>REAL x, REAL y, REAL width, REAL height)<span class="comment">;</span></span><br><span class="line">Status FillRectangles(const <span class="keyword">Brush* </span><span class="keyword">brush, </span>const RectF* rects, INT <span class="built_in">count</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>用指定刷子 Brush，填充 rect 的内部区域，无边线，填充区域包括矩形的左边界和上边 界，但不包括矩形的右边界和下边界。功能与 GDI 的 FillRect 函数类似：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FillRect</span><span class="params">( LPCRECT lpRect, CBrush* pBrush )</span></span>;</span><br></pre></td></tr></table></figure>
<p>但是，GDI 中没有同时填充一个矩形数组的函数。不过 GDI 却有 GDI+中所没有的画填充圆 角矩形的函数 FillSolidRect。</p>
<p>（2） 画填充椭圆 FillEllipse</p>
<p>GDI+中有 4 个重载的绘制填充椭圆的方法，前 2 个为整数版，后 2 个为浮点数版：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Status FillEllipse(<span class="keyword">const</span> Brush* brush, <span class="keyword">const</span> Rect&amp; <span class="built_in">rect</span>);</span><br><span class="line">Status FillEllipse(<span class="keyword">const</span> Brush* brush, INT x, INT y, INT <span class="built_in">width</span>, INT <span class="built_in">height</span>); </span><br><span class="line">Status FillEllipse(<span class="keyword">const</span> Brush* brush, <span class="keyword">const</span> RectF&amp; <span class="built_in">rect</span>);</span><br><span class="line">Status FillEllipse(<span class="keyword">const</span> Brush* brush, REAL x, REAL y, REAL <span class="built_in">width</span>, REAL <span class="built_in">height</span>);</span><br></pre></td></tr></table></figure>
<p>GDI 中没有类似函数，但可以用（采用当前刷填充的）Ellipse 函数来代替。</p>
<p>（3） 画饼图 DrawPie</p>
<p>GDI+中有 4 个重载的绘制饼图的方法，前 2 个为整数版，后 2 个为浮点数版：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Status</span> DrawPie(const Pen* pen, const Rect&amp; rect, <span class="keyword">REAL</span> startAngle, <span class="keyword">REAL</span> sweepAngle);</span><br><span class="line"><span class="keyword">Status</span> DrawPie(const Pen* pen, <span class="built_in">INT</span> x, <span class="built_in">INT</span> y, <span class="built_in">INT</span> width, <span class="built_in">INT</span> height, <span class="keyword">REAL</span> startAngle, <span class="keyword">REAL</span> sweepAngle);</span><br><span class="line"><span class="keyword">Status</span> DrawPie(const Pen* pen, const RectF&amp; rect, <span class="keyword">REAL</span> startAngle, <span class="keyword">REAL</span> sweepAngle);</span><br><span class="line"><span class="keyword">Status</span> DrawPie(const Pen* pen, <span class="keyword">REAL</span> x, <span class="keyword">REAL</span> y, <span class="keyword">REAL</span> width, <span class="keyword">REAL</span> height, <span class="keyword">REAL</span> startAngle, <span class="keyword">REAL</span> sweepAngle);</span><br></pre></td></tr></table></figure>
<p>与 GDI 的下列函数类似，但是部分输入参数的含义有所不同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">Pie</span><span class="params">( <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> x3, <span class="keyword">int</span> y3, <span class="keyword">int</span> x4, <span class="keyword">int</span> y4 )</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">Pie</span><span class="params">( LPCRECT lpRect, POINT ptStart, POINT ptEnd )</span></span>;</span><br></pre></td></tr></table></figure>
<p>例如（参见图 14-14）：</p>
<p><img src="../img/gdip-编程基础/Image_023.jpg" alt="image"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawPies</span><span class="params">(Graphics &amp;graph, <span class="keyword">const</span> Color cols[], Point &amp;O, <span class="keyword">int</span> r, <span class="keyword">const</span> <span class="keyword">float</span> data[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">Rect <span class="title">rect</span><span class="params">(O.X - r, O.Y - r, <span class="number">2</span> * r, <span class="number">2</span> * r)</span></span>;</span><br><span class="line">    <span class="keyword">float</span> startAngle = <span class="number">0</span>, sweepAngle; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; n; i++) &#123;</span><br><span class="line">        sweepAngle = data[i] * <span class="number">360.0f</span>; </span><br><span class="line">        graph.FillPie(&amp;SolidBrush(cols[i]), rect, startAngle, sweepAngle);</span><br><span class="line">        startAngle += sweepAngle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> CGdipDrawView::OnDraw(CDC* pDC) &#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="function">Graphics <span class="title">graph</span><span class="params">(pDC-&amp;gt;m_hDC)</span></span>;</span><br><span class="line">    Color cols[] = &#123;Color::Red, Color::Green, Color::Blue, Color::Aqua&#125;;</span><br><span class="line">    <span class="keyword">float</span> data[] = &#123;<span class="number">0.2f</span>, <span class="number">0.4f</span>, <span class="number">0.1f</span>, <span class="number">0.3f</span>&#125;; </span><br><span class="line">    DrawPies(graph, cols, Point(<span class="number">200</span>, <span class="number">200</span>), <span class="number">100</span>, data, <span class="number">4</span>);</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（4） 画填充多边形 FillPolygon</p>
<p>GDI+中有 4 个重载的绘制填充多边形的方法，前 2 个为整数版，后 2 个为浮点数版：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Status FillPolygonconst <span class="keyword">Brush* </span><span class="keyword">brush, </span>const Point* points, INT <span class="built_in">count</span>)<span class="comment">; </span></span><br><span class="line">Status FillPolygon(const <span class="keyword">Brush* </span><span class="keyword">brush, </span>const Point* points, INT <span class="built_in">count</span>, FillMode fillMode)<span class="comment">;</span></span><br><span class="line">Status FillPolygon(const <span class="keyword">Brush* </span><span class="keyword">brush, </span>const PointF* points, INT <span class="built_in">count</span>)<span class="comment">;</span></span><br><span class="line">Status FillPolygon(const <span class="keyword">Brush* </span><span class="keyword">brush, </span>const PointF* points, INT <span class="built_in">count</span>, FillMode fillMode)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>其中，填充模式参数 FillMode，可取如下两个值之一（参见 8.5.3 中的 1．）：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    FillModeAlternate, <span class="regexp">//</span> 交替模式——按奇偶规则填充（默认模式）</span><br><span class="line">    FillModeWinding /<span class="regexp">/ 环绕模式——按非零环绕规则填充</span></span><br><span class="line"><span class="regexp">&#125; FillMode;</span></span><br></pre></td></tr></table></figure>
<p>对简单图形，这两种模式的效果是一样的，但对复杂图形，特别是有穿插的图，结果可 能是不同的。例如（画五角星，参见图 14-15）：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 定义五角星顶点数组</span><br><span class="line"><span class="symbol">const</span> int n = <span class="number">5</span><span class="comment">; </span></span><br><span class="line"><span class="symbol">Point</span> <span class="built_in">p1</span>(<span class="number">100</span>, <span class="number">0</span>)<span class="comment">; </span></span><br><span class="line"><span class="symbol">Point</span> <span class="built_in">p2</span>(<span class="number">195</span>, <span class="number">69</span>)<span class="comment">; </span></span><br><span class="line"><span class="symbol">Point</span> <span class="built_in">p3</span>(<span class="number">159</span>, <span class="number">181</span>)<span class="comment">;</span></span><br><span class="line"><span class="symbol">Point</span> <span class="built_in">p4</span>(<span class="number">41</span>, <span class="number">181</span>)<span class="comment">; Point p5(5, 69); </span></span><br><span class="line"><span class="symbol">Point</span> ps0[n] = &#123;<span class="built_in">p1</span>, <span class="built_in">p2</span>, <span class="built_in">p3</span>, <span class="built_in">p4</span>, <span class="built_in">p5</span>&#125;<span class="comment">;</span></span><br><span class="line"><span class="symbol">Point</span> ps[n] = &#123;<span class="built_in">p1</span>, <span class="built_in">p3</span>, <span class="built_in">p5</span>, <span class="built_in">p2</span>, <span class="built_in">p4</span>&#125;<span class="comment">;</span></span><br><span class="line">// 创建实心刷对象</span><br><span class="line"><span class="symbol">SolidBrush</span> redBrush(Color(<span class="number">128</span>, <span class="number">0</span>, <span class="number">0</span>))<span class="comment">;</span></span><br><span class="line"><span class="symbol">SolidBrush</span> greenBrush(Color(<span class="number">0</span>, <span class="number">128</span>, <span class="number">0</span>))<span class="comment">;</span></span><br><span class="line"><span class="symbol">SolidBrush</span> <span class="keyword">blueBrush(Color(0, </span><span class="number">0</span>, <span class="number">128</span>))<span class="comment">;</span></span><br><span class="line">// 画五角星</span><br><span class="line"><span class="symbol">Graphics</span> graph(pDC-&gt;m_hDC)<span class="comment">; </span></span><br><span class="line"><span class="symbol">graph.DrawPolygon</span>(&amp;Pen(Color::Red), ps0, n)<span class="comment">; </span></span><br><span class="line"><span class="symbol">graph.DrawPolygon</span>(&amp;Pen(Color::Green), ps, n)<span class="comment">;</span></span><br><span class="line">// 画填充五角星</span><br><span class="line"><span class="symbol">graph.TranslateTransform</span>(<span class="number">200</span>, <span class="number">0</span>)<span class="comment">; // 右移 200 像素</span></span><br><span class="line"><span class="symbol">graph.FillPolygon</span>(&amp;redBrush, ps0, n)<span class="comment">; </span></span><br><span class="line"><span class="symbol">graph.TranslateTransform</span>(<span class="number">200</span>, <span class="number">0</span>)<span class="comment">; </span></span><br><span class="line"><span class="symbol">graph.FillPolygon</span>(&amp;greenBrush, ps, n, FillModeAlternate)<span class="comment">; </span></span><br><span class="line"><span class="symbol">graph.TranslateTransform</span>(<span class="number">200</span>, <span class="number">0</span>)<span class="comment">; </span></span><br><span class="line"><span class="symbol">graph.FillPolygon</span>(&amp;<span class="keyword">blueBrush, </span>ps, n, FillModeWinding)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><img src="../img/gdip-编程基础/Image_024.jpg" alt="image"></p>
<p>多边形 交替/环绕模式 交替模式 环绕模式 </p>
<p>图 14-15 填充多边形（五角星）</p>
<p>GDI 中也没有与画填充多边形类似的专门函数，但可以用（采用当前刷填充的）Polygon 来代替。</p>
<h3 id="1-6-5-画曲线的方法"><a href="#1-6-5-画曲线的方法" class="headerlink" title="1.6.5 画曲线的方法"></a>1.6.5 画曲线的方法</h3><p>前面讲的各种画线状图或填充图的 GDI+方法，虽然在形式上与 GDI 的有所不同（方法 名前加了 Draw 或 Fill、将笔或刷作为第一个输入参数、部分输的位置入参数改成了大小参 数、并增加了浮点数版），但是在功能上却是相同的。</p>
<p>现在要讲的曲线绘制，则是 GDI+新增加的内容。曲线在机械设计、工程建筑和图形动 画等领域，都有十分广泛应用。</p>
<p>常用的曲线有 Bezier（贝塞尔）曲线和样条（spline）曲线。贝塞尔曲线比较简单，适 合于画控制点少的曲线。当控制点太多时，要不曲线的次数（比点数少 1）太高，要不拼接 比较困难，而且没有局部性（即修改一点影响全局），性能不太好。而样条曲线则可以画任 意多个控制点的曲线，曲线的次数也可以指定（一般为二次或三次），并且具有局部性。贝 塞尔曲线特别是样条曲线有很多变种。常见的贝塞尔曲线有普通贝塞尔曲线和有理贝塞尔曲 线。常用的样条曲线有：B 样条、β 样条、Hermite（厄密）样条、基样条（cardinal splines）、 Kochanek- Bartels 样条和 Catmull-Rom 样条等。</p>
<p>GDI+中所实现的是普通贝塞尔曲线（不过控制点，位于控制多边形的凸包之内）和基 样条曲线（过控制点）。有关曲线和曲面构造方法，会在课程《计算机图形学》中介绍。</p>
<p>（1）基样条曲线（cardinal spline curve）</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Status</span> DrawCurve(const Pen* pen, const Point* points, <span class="built_in">INT</span> <span class="built_in">count</span>, <span class="keyword">REAL</span> tension = <span class="number">0.</span>f); </span><br><span class="line"><span class="keyword">Status</span> DrawCurve(const Pen* pen, const PointF* points, <span class="built_in">INT</span> <span class="built_in">count</span>, <span class="keyword">REAL</span> tension = <span class="number">0.</span>f); </span><br><span class="line"><span class="keyword">Status</span> DrawClosedCurve(const Pen *pen, const Point* points, <span class="built_in">INT</span> <span class="built_in">count</span>, <span class="keyword">REAL</span> tension = <span class="number">0.</span>f);</span><br><span class="line"><span class="keyword">Status</span> DrawClosedCurve(const Pen *pen, const PointF* points, <span class="built_in">INT</span> <span class="built_in">count</span>, <span class="keyword">REAL</span> tension = <span class="number">0.</span>f);</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><p>参数 tension（张力）指定曲线的弯曲程度，tension = 0.0（直线）~1.0（最弯曲）。</p>
</li>
<li><p>DrawClosedCurve 方法（连接首尾点）画封闭的基样条曲线。 例如（参见图 14-16）：</p>
</li>
</ul>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void DrawPoints(Graphics &amp;<span class="keyword">graph</span>, <span class="keyword">const</span> Color &amp;col, int r, <span class="keyword">const</span> Point* points, INT <span class="keyword">count</span>) &#123; </span><br><span class="line">    <span class="comment">// 自定义的画点列函数 SolidBrush brush(col);</span></span><br><span class="line">    <span class="keyword">for</span> (int i = 0; i &lt; <span class="keyword">count</span>; i++) </span><br><span class="line">        <span class="keyword">graph</span>.FillEllipse(&amp;brush, Rect(points[i].X - r,</span><br><span class="line">            points[i].Y - r, 2 * r, 2 * r));</span><br><span class="line">&#125;</span><br><span class="line">Graphics <span class="keyword">graph</span>(pDC-&gt;m_hDC);</span><br><span class="line"><span class="comment">// 定义 Pen 对象和 Point 对象的数组</span></span><br><span class="line">Pen greenPen(Color::Green, 3);</span><br><span class="line">Point p1(10, 100), p2(100, 50), p3(300, 10), p4(400, 100);</span><br><span class="line">Point ps[4] = &#123;p1, p2, p3, p4&#125;;</span><br><span class="line"><span class="comment">// 绘制不同张力的基样条曲线</span></span><br><span class="line"><span class="keyword">graph</span>.DrawCurve(&amp;Pen(Color::Magenta), ps, 4, 1.0);</span><br><span class="line"><span class="keyword">graph</span>.DrawCurve(&amp;greenPen, ps, 4, 0.5);</span><br><span class="line"><span class="keyword">graph</span>.DrawCurve(&amp;Pen(Color::Blue), ps, 4, 0.0); </span><br><span class="line">DrawPoints(<span class="keyword">graph</span>, Color::Red, 5, ps, 4); <span class="comment">// 绘制曲线的控制点</span></span><br><span class="line"><span class="comment">// 绘制默认张力的基样条、封闭基样条与贝塞尔曲线</span></span><br><span class="line"><span class="keyword">graph</span>.TranslateTransform(450, 0); <span class="comment">// 水平右移 450 个像素</span></span><br><span class="line"><span class="keyword">graph</span>.DrawCurve(&amp;greenPen, ps, 4);</span><br><span class="line"><span class="keyword">graph</span>.DrawClosedCurve(&amp;Pen(Color::Aqua), ps, 4);</span><br><span class="line"><span class="keyword">graph</span>.DrawBeziers(&amp;Pen(Color::Chocolate), ps, 4); </span><br><span class="line">DrawPoints(<span class="keyword">graph</span>, Color::Red, 5, ps, 4); <span class="comment">// 绘制曲线的控制点</span></span><br></pre></td></tr></table></figure>
<p><img src="../img/gdip-编程基础/Image_025.jpg" alt="image"></p>
<p>不同张力的基样条曲线 基样条、封闭基样条与贝塞尔曲线 </p>
<p>图 14-16 基样条曲线与贝塞尔曲线</p>
<p>（2）贝塞尔曲线（Bezier curve）</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Status DrawBezier(<span class="keyword">const</span> Pen* pen, <span class="keyword">INT</span> x1, <span class="keyword">INT</span> y1, <span class="keyword">INT</span> x2, <span class="keyword">INT</span> y2, <span class="keyword">INT</span> x3, <span class="keyword">INT</span> y3, <span class="keyword">INT</span> x4, <span class="keyword">INT</span> y4);</span><br><span class="line">Status DrawBezier(<span class="keyword">const</span> Pen* pen, <span class="keyword">const</span> Point&amp; pt1, <span class="keyword">const</span> Point&amp; pt2, <span class="keyword">const</span> Point&amp; pt3, <span class="keyword">const</span> Point&amp; pt4);</span><br><span class="line">Status DrawBeziers(<span class="keyword">const</span> Pen* pen, <span class="keyword">const</span> Point* points, <span class="keyword">INT</span> count);</span><br><span class="line">... <span class="comment">// 对应的浮点版本</span></span><br></pre></td></tr></table></figure>
<p>（3）填充封闭基样条曲线</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">FillClosedCurve</span><span class="params">(<span class="keyword">const</span> Brush* brush, <span class="keyword">const</span> Point* points, INT count)</span></span>;</span><br><span class="line"><span class="function">Status <span class="title">FillClosedCurve</span><span class="params">(<span class="keyword">const</span> Brush* brush, <span class="keyword">const</span> Point* points, INT count, FillMode fillMode, REAL tension = <span class="number">0.5f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">... <span class="comment">// 对应的浮点版本</span></span><br></pre></td></tr></table></figure>
<p>例如，将前面画图 14-15 所对应的填充多边形例子中的画填充五角星的三个语句中的 FillPolygon 方法，改为填充封闭基样条曲线方法 FillClosedCurve，结果如图 14-17 所示。</p>
<p><img src="../img/gdip-编程基础/Image_026.jpg" alt="image"></p>
<p>多边形 交替/环绕模式 交替模式 环绕模式 </p>
<p>图 14-17 填充闭曲线</p>
<h3 id="1-6-6-平滑处理"><a href="#1-6-6-平滑处理" class="headerlink" title="1.6.6 平滑处理"></a>1.6.6 平滑处理</h3><p>可以利用 Graphics 类的设置平滑模式方法</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Status SetSmoothingMode(<span class="name">SmoothingMode</span> smoothingMode)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>来设置绘图时的平滑化处理。其中的输入参数为枚举类型：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef enum &#123;</span><br><span class="line">    <span class="type">SmoothingModeInvalid</span> = <span class="type">QualityModeInvalid</span>, //无效（保留）</span><br><span class="line">    <span class="type">SmoothingModeDefault</span> = <span class="type">QualityModeDefault</span>, // 默认（低质，无平滑处理） </span><br><span class="line">    <span class="type">SmoothingModeHighSpeed</span> = <span class="type">QualityModeLow</span>, // 高速（低质，无平滑处理） </span><br><span class="line">    <span class="type">SmoothingModeHighQuality</span> = <span class="type">QualityModeHigh</span>, // 高质（使用 8*4 盒过滤器） </span><br><span class="line">    <span class="type">SmoothingModeNone</span>, // 无平滑处理</span><br><span class="line">    <span class="type">SmoothingModeAntiAlias8x4</span>, // 使用 8*4 盒过滤器（库中无） </span><br><span class="line">    <span class="type">SmoothingModeAntiAlias</span> = </span><br><span class="line">    <span class="type">SmoothingModeAntiAlias8x4</span>, // 使用 8*4 盒过滤器 </span><br><span class="line">    <span class="type">SmoothingModeAntiAlias8x8</span> // 使用 8*8 盒过滤器（最高质，库中也无）</span><br><span class="line">&#125; <span class="type">SmoothingMode</span>;</span><br></pre></td></tr></table></figure>
<p><img src="../img/gdip-编程基础/Image_027.jpg" alt="image"></p>
<p>图 14-18 平滑处理</p>
<p>例如（参见图 14-18）：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Graphics graph(<span class="name">pDC-&amp;gt</span><span class="comment">;m_hDC); </span></span><br><span class="line">Pen pen(<span class="name">Color</span>:<span class="symbol">:Black</span>, <span class="number">4</span>)<span class="comment">;</span></span><br><span class="line">Rect rect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">200</span>, <span class="number">200</span>)<span class="comment">;</span></span><br><span class="line">graph.DrawRectangle(<span class="name">&amp;pen</span>, rect)<span class="comment">; </span></span><br><span class="line">graph.RotateTransform(<span class="number">1</span>)<span class="comment">; </span></span><br><span class="line">graph.TranslateTransform(<span class="number">20</span>, <span class="number">20</span>)<span class="comment">;</span></span><br><span class="line">//graph.SetSmoothingMode(<span class="name">SmoothingModeNone</span>)<span class="comment">;</span></span><br><span class="line">graph.DrawRectangle(<span class="name">&amp;pen</span>, rect)<span class="comment">; </span></span><br><span class="line">graph.TranslateTransform(<span class="number">20</span>, <span class="number">20</span>)<span class="comment">; </span></span><br><span class="line">graph.SetSmoothingMode(<span class="name">SmoothingModeAntiAlias</span>)<span class="comment">; </span></span><br><span class="line">graph.DrawRectangle(<span class="name">&amp;pen</span>, rect)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-6-7-清屏方法-Clear"><a href="#1-6-7-清屏方法-Clear" class="headerlink" title="1.6.7 清屏方法 Clear"></a>1.6.7 清屏方法 Clear</h3><p>GDI 中没有用于清屏的专门函数，得自己用背景色画窗口大小的填充矩形，或者调用窗 口类的 Invalidate 和 UpdateWindow 函数。现在，GDI+有了清屏方法 Clear：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Status Clear(<span class="name">const</span> Color <span class="symbol">&amp;color</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>其中的输入参数 color，为用户指定的填充背景色。例如：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Graphics graph<span class="function"><span class="params">(GetDC()-&gt;m_hDC)</span>;</span></span><br><span class="line"><span class="function">…… </span></span><br><span class="line"><span class="function"><span class="title">graph</span>.<span class="title">Clear</span><span class="params">(Color::White)</span>;</span></span><br></pre></td></tr></table></figure>
<h2 id="1-7-笔和刷"><a href="#1-7-笔和刷" class="headerlink" title="1.7 笔和刷"></a>1.7 笔和刷</h2><p>本节介绍 GDI+的两类绘图工具——笔和刷，它们与 GDI 的相比新增加了许多功能。</p>
<h3 id="1-7-1-笔"><a href="#1-7-1-笔" class="headerlink" title="1.7.1 笔"></a>1.7.1 笔</h3><p>与 GDI 中的一样，GDI+中的笔（pen）也是画线状图的工具，但是功能更加强大。例 如：透明笔、图案笔、自定义虚线风格、线帽、笔的缩放和旋转、笔的连接点属性等。</p>
<p>GDI+中的笔对应于 Pen 类，被定义在 GdiplusPen.h 头文件中。 笔的构造方法主要有两个：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pen(<span class="keyword">const</span> Color &amp;<span class="built_in">color</span>, REAL <span class="built_in">width</span> = <span class="number">1.0</span>); <span class="comment">// 单色笔</span></span><br><span class="line">Pen(<span class="keyword">const</span> Brush *brush, REAL <span class="built_in">width</span> = <span class="number">1.0</span>); <span class="comment">// 纹理图案笔</span></span><br></pre></td></tr></table></figure>
<p>其中，最常用的是第一个，它构造一个颜色为 color，宽度为 width（默认为 1）的单色笔。 如果颜色的α 值&lt;255，则所创建的笔就是带透明度的笔。</p>
<p>（1）笔对齐</p>
<p>当笔宽大于 1 时，默认情况下，是以笔的中心与绘图坐标对齐。但是，也可以采用 Pen类的方法：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Status SetAlignment(<span class="name">PenAlignment</span> penAlignment)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>设置为内对齐，其输入参数取枚举类型 PenAlignment 的符号常量：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    PenAlignmentCenter = <span class="number">0</span>, <span class="regexp">//</span> 中心对齐（默认值）</span><br><span class="line">    PenAlignmentInset = <span class="number">1</span> /<span class="regexp">/ 内对齐</span></span><br><span class="line"><span class="regexp">&#125; PenAlignment;</span></span><br></pre></td></tr></table></figure>
<p>例如（输出结果如图 14-19 所示）：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Graphics graph(<span class="name">pDC-&amp;gt</span><span class="comment">;m_hDC); </span></span><br><span class="line">Rect rect(<span class="number">20</span>, <span class="number">20</span>, <span class="number">300</span>, <span class="number">200</span>)<span class="comment">;</span></span><br><span class="line">Pen pen(<span class="name">Color</span>:<span class="symbol">:Green</span>, <span class="number">30</span>), redPen(<span class="name">Color</span>:<span class="symbol">:Red</span>)<span class="comment">; </span></span><br><span class="line">graph.DrawEllipse(<span class="name">&amp;pen</span>, rect)<span class="comment">; </span></span><br><span class="line">graph.DrawRectangle(<span class="name">&amp;redPen</span>, rect)<span class="comment">; </span></span><br><span class="line">pen.SetAlignment(<span class="name">PenAlignmentInset</span>)<span class="comment">; </span></span><br><span class="line">graph.TranslateTransform(<span class="number">340</span>, <span class="number">0</span>)<span class="comment">; </span></span><br><span class="line">graph.DrawEllipse(<span class="name">&amp;pen</span>, rect)<span class="comment">; </span></span><br><span class="line">graph.DrawRectangle(<span class="name">&amp;redPen</span>, rect)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><img src="../img/gdip-编程基础/Image_028.jpg" alt="image"></p>
<p>a) 中心对齐（默认值） b) 内对齐</p>
<p>图 14-19 笔对齐</p>
<p>（2）图案笔</p>
<p>笔类 Pen 的第二个构造方法，是从刷子来创建笔，如果是单色的实心刷，则相当于第一 个笔构造方法。如果刷子为条纹（影线）或纹理（图像）等图案刷，则该构造函数所创见的 就是对应的图案笔。</p>
<p>例如（条纹笔画椭圆，参见图 14-20）：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">HatchBrush</span> <span class="selector-tag">hBrush</span>(HatchStyleCross, <span class="attribute">Color</span>::Green, <span class="attribute">Color</span>::Red); <span class="comment">// 创建十字线条纹刷 </span></span><br><span class="line"><span class="selector-tag">Pen</span> <span class="selector-tag">hPen</span>(&amp;**hBrush**, <span class="number">40</span>); <span class="comment">// 创建宽度为 40 像素的条纹笔 </span></span><br><span class="line"><span class="selector-tag">graph</span><span class="selector-class">.DrawEllipse</span>(&amp;hPen, <span class="number">20</span>, <span class="number">20</span>, <span class="number">400</span>, <span class="number">250</span>); <span class="comment">// 画椭圆</span></span><br></pre></td></tr></table></figure>
<p><img src="../img/gdip-编程基础/Image_029.jpg" alt="image"></p>
<p>图 14-20 条纹笔椭圆</p>
<p><img src="../img/gdip-编程基础/Image_030.jpg" alt="image"></p>
<p>图 14-21 纹理笔椭圆 </p>
<p>又例如（纹理笔画椭圆，参见图 14-21）：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Image</span> <span class="selector-tag">img</span>(L<span class="string">"张东健.bmp"</span>); <span class="comment">// 创建图像对象，并装入图像文件</span></span><br><span class="line"><span class="selector-tag">TextureBrush</span> <span class="selector-tag">tBrush</span>(&amp;img); <span class="comment">// 创建纹理刷</span></span><br><span class="line"><span class="selector-tag">Pen</span> <span class="selector-tag">tPen</span>(&amp;**tBrush**, <span class="number">80</span>); <span class="comment">// 创建宽度为 80 像素的纹理笔 </span></span><br><span class="line"><span class="selector-tag">Graphics</span> <span class="selector-tag">graph</span>(GetDC()-&amp;gt;m_hDC); <span class="comment">// 创建图形对象 </span></span><br><span class="line"><span class="selector-tag">graph</span><span class="selector-class">.DrawEllipse</span>(&amp;tPen, <span class="number">40</span>, <span class="number">40</span>, <span class="number">640</span>, <span class="number">400</span>); <span class="comment">// 画椭圆</span></span><br></pre></td></tr></table></figure>
<p>（3）线型</p>
<p>与 GDI 一样，对 GDI+中的笔，也可以设置线型。所用的方法为：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Status SetDashStyle(<span class="name">DashStyle</span> dashStyle)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>其中的输入参数，为虚线风格枚举 DashStyle：（GdiplusEnums.h） </p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DashStyle</span> &#123;</span></span><br><span class="line">    DashStyleSolid, <span class="regexp">//</span> <span class="number">0</span> 实线 （默认值）</span><br><span class="line">    DashStyleDash, <span class="regexp">//</span> <span class="number">1</span> 虚线</span><br><span class="line">    DashStyleDot, <span class="regexp">//</span> <span class="number">2</span> 点线：</span><br><span class="line">    DashStyleDashDot, <span class="regexp">//</span> <span class="number">3</span> 虚点线：</span><br><span class="line">    DashStyleDashDotDot, <span class="regexp">//</span> <span class="number">4</span> 虚点点线 </span><br><span class="line">    DashStyleCustom /<span class="regexp">/ 5 自定义虚线</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure>
<p><img src="../img/gdip-编程基础/1-7-1-2.png" alt=""></p>
<p>可以用 Pen 类的另一个方法来获取笔的线型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DashStyle <span class="title">GetDashStyle</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>GDI+中的线型，大多数与 GDI 中的相同，区别主要有两点：</p>
<ul>
<li><p>GDI 中的非实线线型，对宽度&gt;1 的笔无效；而 GDI+的笔对任意非零宽度的笔都是有效的。</p>
</li>
<li><p>GDI+中新增了一种风格——自定义虚线风格。 具体的自定义虚线风格，由 Pen 类的设置虚线图案的方法</p>
</li>
</ul>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Status</span> SetDashPattern(const <span class="keyword">REAL</span> *dashArray, <span class="built_in">INT</span> <span class="built_in">count</span>);</span><br></pre></td></tr></table></figure>
<p>来设置，其中的实数数组 dashArray 含若干个正实数（单位为像素），按线、空、线、空、„„ 的交叉方式排列；参数 count 为数组中实数的个数（须&gt;0）。</p>
<p>例如（参见图 14-22）：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Graphics <span class="title">graph</span>(<span class="params">pDC-&gt;m_hDC</span>)</span>;</span><br><span class="line"><span class="function">Pen <span class="title">pen</span>(<span class="params">Color::Black, <span class="number">8</span></span>)</span>; <span class="comment">// 创建宽 8 个像素的黑色笔（画虚线用）</span></span><br><span class="line"><span class="comment">// 线 5、空 2、线 15、空 4（像素）</span></span><br><span class="line">REAL dashVals[<span class="number">4</span>] = &#123;<span class="number">5.0</span>f, <span class="number">2.0</span>f, <span class="number">15.0</span>f, <span class="number">4.0</span>f&#125;;</span><br><span class="line"><span class="function">FontFamily <span class="title">fontFamily</span>(<span class="params">L<span class="string">"Times New Roman"</span></span>)</span>; <span class="comment">// 创建字体族对象</span></span><br><span class="line"><span class="comment">// 创建 5 号字大小的 Times New Roman 字体</span></span><br><span class="line"><span class="function">Font <span class="title">font</span>(<span class="params">&amp;fontFamily, <span class="number">10.5</span></span>)</span>;</span><br><span class="line"><span class="comment">// 创建绿色的实心刷（写字符串用）</span></span><br><span class="line"><span class="function">SolidBrush <span class="title">brush</span>(<span class="params">Color(<span class="number">0</span>, <span class="number">128</span>, <span class="number">0</span></span>))</span>;</span><br><span class="line"><span class="comment">// 笔的虚线风格枚举常量的名称字符串数组</span></span><br><span class="line">CString strs[] = &#123;L<span class="string">"DashStyleSolid"</span>, L<span class="string">"DashStyleDash"</span>, L<span class="string">"DashStyleDot"</span>, L<span class="string">"DashStyleDashDot"</span>, L<span class="string">"DashStyleDashDotDot"</span>, L<span class="string">"DashStyleCustom"</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt;= <span class="number">5</span>; i++) &#123; <span class="comment">// 绘制各种风格的虚线及其名称串</span></span><br><span class="line">    pen.**SetDashStyle**((DashStyle)i); <span class="comment">// 设置笔的虚线风格</span></span><br><span class="line">    <span class="comment">// 设置自定义虚线图案</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>) pen.SetDashPattern(dashVals, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 画虚线</span></span><br><span class="line">    graph.DrawLine(&amp;pen, <span class="number">10</span>, <span class="number">10</span> + i * <span class="number">20</span>, <span class="number">400</span>, <span class="number">10</span> + i * <span class="number">20</span>);</span><br><span class="line">    <span class="comment">// 绘制虚线风格枚举常量名称字符串</span></span><br><span class="line">    graph.DrawString(strs[i], <span class="number">-1</span>, &amp;font,</span><br><span class="line">        PointF(<span class="number">410</span>, <span class="number">2</span> + i * <span class="number">20</span>), &amp;brush);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="../img/gdip-编程基础/Image_037.jpg" alt="image"></p>
<p>图 14-22 虚线风格</p>
<p>还可以用 Pen 类的另一个方法来获取笔的自定义虚线图案数据：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INT</span> GetDashPatternCount(<span class="keyword">VOID</span>); <span class="comment">// 获取虚线数组中实数的个数</span></span><br><span class="line">Status GetDashPattern(REAL *dashArray, <span class="keyword">INT</span> <span class="keyword">count</span>); <span class="comment">// 获取虚线数组</span></span><br></pre></td></tr></table></figure>
<p>（4）线帽</p>
<p>线帽（line cap）是指线条两端的外观，默认为正方形，也可以用 Pen 类的下列方法来 设置不同的线端形状：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SetStartCap</span><span class="params">(LineCap startCap)</span></span>; <span class="comment">// 设置起点的线帽</span></span><br><span class="line"><span class="function">Status <span class="title">SetEndCap</span><span class="params">(LineCap endCap)</span></span>; <span class="comment">// 设置终点的线帽</span></span><br><span class="line"><span class="comment">// 设置起点、终点和虚线的线帽</span></span><br><span class="line"><span class="function">Status <span class="title">SetLineCap</span><span class="params">(LineCap startCap, LineCap endCap, DashCap dashCap)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中的线帽枚举 LineCap 为（GdiplusEnums.h）： </p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    LineCapFlat = <span class="number">0</span>, <span class="comment">// 平线，直线起点位于平线的中点（默认值）</span></span><br><span class="line">    LineCapSquare = <span class="number">1</span>, <span class="comment">// 方形，高度=线宽，直线起点位于正方形中心 </span></span><br><span class="line">    LineCapRound = <span class="number">2</span>, <span class="comment">// 圆形，直径=线宽，直线起点位于圆心 </span></span><br><span class="line">    LineCapTriangle = <span class="number">3</span>, <span class="comment">// 三角，高度=线宽，直线起点位于其底边中点 </span></span><br><span class="line">    LineCapNoAnchor = <span class="number">0</span>x10, <span class="comment">// 无锚，同平线</span></span><br><span class="line">    LineCapSquareAnchor = <span class="number">0</span>x11, <span class="comment">// 方形锚，高度&amp;gt;线宽，直线起点位于正方形中心 LineCapRoundAnchor = 0x12, // 圆形锚，直径&amp;gt;线宽，直线起点位于圆心 LineCapDiamondAnchor = 0x13, // 菱形锚，高度&amp;gt;线宽，直线起点位于菱形中心 LineCapArrowAnchor = 0x14, // 箭头锚，高度&amp;gt;线宽，直线起点位于箭头的尖点 LineCapCustom = 0xff // 自定义线帽</span></span><br><span class="line">&#125; LineCap;</span><br></pre></td></tr></table></figure>
<p>自定义线帽，需要用到 GDI+专门为此定义的类 CustomLineCap。其构造函数为：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CustomLineCap(<span class="name">const</span> GraphicsPath *fillPath, const GraphicsPath *strokePath, LineCap baseCap, REAL baseInset)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>其中要用到图形路径类 GraphicsPath，该类中有图形各种添加图形方法，只是把 Graphics 类</p>
<p>绘图方法名中的 Draw 改成 Add 即可。例如：AddLine、AddRectangle 和 AddPolygon 等。使 用时，可以先创建一个空路径，然后调用这些添加图形方法若干次，就可以生成路径了。</p>
<p><img src="../img/gdip-编程基础/Image_038.jpg" alt="image"></p>
<p>例如（各类线帽，参见图 14-23 和图 14-24）：</p>
<p><img src="../img/gdip-编程基础/Image_039.jpg" alt="image"></p>
<p>箭头线帽 构造箭头线帽头尾所使用的坐标系 </p>
<p>图 14-23 自定义线帽</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义箭头线帽</span></span><br><span class="line">GraphicsPath startPath, endPath; <span class="comment">// 创建起点和终点路径对象</span></span><br><span class="line">startPath.AddRectangle(Rect(-<span class="number">10</span>, -<span class="number">5</span>, <span class="number">20</span>, <span class="number">10</span>)); <span class="comment">// 起点矩形</span></span><br><span class="line">Point polygonPoints[<span class="number">4</span>] = &#123;Point(<span class="number">0</span>, -<span class="number">20</span>), Point(<span class="number">10</span>, <span class="number">0</span>),</span><br><span class="line">Point(<span class="number">0</span>, -<span class="number">10</span>), Point(-<span class="number">10</span>, <span class="number">0</span>)&#125;;</span><br><span class="line">endPath.AddPolygon(polygonPoints, <span class="number">4</span>); <span class="comment">// 终点箭头 </span></span><br><span class="line">CustomLineCap startCap(<span class="literal">NULL</span>, <span class="meta">&amp;startPath); <span class="comment">// 创建起点线帽 </span></span></span><br><span class="line">CustomLineCap endCap(<span class="literal">NULL</span>, <span class="meta">&amp;endPath); <span class="comment">// 创建终点线帽</span></span></span><br><span class="line"><span class="comment">// 定义笔</span></span><br><span class="line">Pen pen(Color::Black, <span class="number">20</span>); <span class="comment">// 画带线帽粗线的黑笔</span></span><br><span class="line">Pen redPen(Color::Red); <span class="comment">// 画不带线帽细线的红笔</span></span><br><span class="line"><span class="comment">// 中英文线帽字符串数组</span></span><br><span class="line">CString cstrs[] = &#123;L<span class="string">"平线帽"</span>, L<span class="string">"方线帽"</span>, L<span class="string">"圆线帽"</span>, L<span class="string">"三角线帽"</span>,</span><br><span class="line">L<span class="string">"无锚线帽"</span>, L<span class="string">"方锚线帽"</span>, L<span class="string">"圆锚线帽"</span>, L<span class="string">"菱锚线帽"</span>, L<span class="string">"箭锚线帽"</span>, L<span class="string">"定制线帽"</span>&#125;;</span><br><span class="line">CString estrs[] = &#123;L<span class="string">"LineCapFlat"</span>, L<span class="string">"LineCapSquare"</span>,</span><br><span class="line">    L<span class="string">"LineCapRound"</span>, L<span class="string">"LineCapTriangle"</span>, L<span class="string">"LineCapNoAnchor"</span>, L<span class="string">"LineCapSquareAnchor"</span>, </span><br><span class="line">    L<span class="string">"LineCapRoundAnchor"</span>, L<span class="string">"LineCapDiamondAnchor"</span>, L<span class="string">"LineCapArrowAnchor"</span>, </span><br><span class="line">    L<span class="string">"LineCapCustom"</span>&#125;;</span><br><span class="line"><span class="comment">// 创建字体</span></span><br><span class="line">FontFamily fontFamily(L<span class="string">"Times New Roman"</span>); <span class="comment">// 对应中文的"宋体" </span></span><br><span class="line">Font font(<span class="meta">&amp;fontFamily, 10.5); <span class="comment">// 五号字</span></span></span><br><span class="line"><span class="comment">// 绘制各种线帽</span></span><br><span class="line">Graphics graph(pDC-<span class="meta">&amp;gt;m_hDC);</span></span><br><span class="line">for (int i = <span class="number">0</span>; i <span class="meta">&amp;lt;= 9; i++) &#123; </span></span><br><span class="line">    <span class="comment">// 画线循环</span></span><br><span class="line">    LineCap lc = (LineCap)(i <span class="meta">&amp;lt; 4 ? i : i + 12); <span class="comment">// 线帽常量（整数） </span></span></span><br><span class="line">    if(i <span class="meta">&amp;lt; 9) </span></span><br><span class="line">        pen.SetLineCap(lc, lc, DashCapFlat); <span class="comment">// 标准线帽 </span></span><br><span class="line">    else </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 自定义线帽（i = 9）</span></span><br><span class="line">        pen.SetCustomStartCap(<span class="meta">&amp;startCap); <span class="comment">// 设置自定义的起点线帽 </span></span></span><br><span class="line">        pen.SetCustomEndCap(<span class="meta">&amp;endCap); <span class="comment">// 设置自定义的终点线帽 </span></span></span><br><span class="line">        pen.SetWidth(<span class="number">3.0</span>f); <span class="comment">// 重新设置线宽为 3 个像素</span></span><br><span class="line">    &#125;</span><br><span class="line">    int y = <span class="number">20</span> + i * <span class="number">40</span>; <span class="comment">// 计算直线的垂直坐标 </span></span><br><span class="line">    graph.DrawLine(<span class="meta">&amp;pen, 100, y, 400, y); <span class="comment">// 画带线帽的粗线 </span></span></span><br><span class="line">    graph.DrawLine(<span class="meta">&amp;redPen, 100, y, 400, y); <span class="comment">// 画不带线帽的细线</span></span></span><br><span class="line">    <span class="comment">// 绘制中英文线帽字符串</span></span><br><span class="line">    graph.DrawString(cstrs[i], -<span class="number">1</span>, <span class="meta">&amp;font,</span></span><br><span class="line">    PointF(<span class="number">15.0</span>f, y - <span class="number">8.0</span>f), <span class="meta">&amp;brush); </span></span><br><span class="line">    graph.DrawString(estrs[i], -<span class="number">1</span>, <span class="meta">&amp;font,</span></span><br><span class="line">    PointF(<span class="number">425.0</span>f, y - <span class="number">8.0</span>f), <span class="meta">&amp;brush);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="../img/gdip-编程基础/Image_040.png" alt="image"></p>
<p>图 14-24 线帽的种类 图 14-25 箭头线帽的旋转直线簇 又例如（旋转箭头线帽，参见图 14-25）：</p>
<figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// startCap 和 endCap 的创建同上例，需包含头文件 &amp;lt;math.h&amp;gt;</span></span><br><span class="line">Pen pen(<span class="keyword">Color</span>::DarkGreen, <span class="number">2</span>)<span class="comment">; </span></span><br><span class="line">pen.SetCustomStartCap(&amp;startCap)<span class="comment">; </span></span><br><span class="line">pen.SetCustomEndCap(&amp;endCap)<span class="comment">;</span></span><br><span class="line"><span class="keyword">double</span> radian = <span class="number">3.14159265358979323846</span> / <span class="number">180.0</span><span class="comment">;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &amp;lt; 360; i += 10) </span></span><br><span class="line">    graph.DrawLine(&amp;pen, <span class="number">220</span>, <span class="number">220</span>, <span class="number">220</span> + (<span class="keyword">INT</span>) (<span class="number">200</span> *</span><br><span class="line">        <span class="keyword">cos</span>(i * radian)), <span class="number">220</span> + (<span class="keyword">INT</span>) (<span class="number">200</span> * <span class="keyword">sin</span>(i * radian)))<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>方法 SetLineCap 的最后一个输入参数 DashCap dashCap，用于设置虚线内部各线段端点 的形状。其取值是枚举类型（GdiplusEnums.h）：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    DashCapFlat = <span class="number">0</span>, <span class="regexp">//</span> 平线（默认值） </span><br><span class="line">    DashCapRound = <span class="number">2</span>, <span class="regexp">//</span> 圆形 </span><br><span class="line">    DashCapTriangle = <span class="number">3</span> /<span class="regexp">/ 三角</span></span><br><span class="line"><span class="regexp">&#125; DashCap;</span></span><br></pre></td></tr></table></figure>
<p>可见，只有三种选择：平、圆和三角。之所以枚举常量所对应的值不连续，是因为要同 LineCap 枚举的对应常量一致。</p>
<p>注意，虚线帽的设置，只影响其虚线内部的线段，不会影响整条虚线的头尾形状，它们 是由 SetLineCap 方法的前两个参数来分别设置的。例如（参见图 14-26）：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Graphics graph(<span class="name">pDC-&amp;gt</span><span class="comment">;m_hDC);</span></span><br><span class="line">Pen pen(<span class="name">Color</span>:<span class="symbol">:Black</span>, <span class="number">10</span>)<span class="comment">;</span></span><br><span class="line">pen.SetLineCap(<span class="name">LineCapFlat</span>, LineCapFlat, **DashCapFlat**)<span class="comment">;</span></span><br><span class="line">//pen.SetLineCap(<span class="name">LineCapFlat</span>, LineCapFlat, **DashCapRound**)<span class="comment">;</span></span><br><span class="line">//pen.SetLineCap(<span class="name">LineCapFlat</span>, LineCapFlat, **DashCapTriangle**)<span class="comment">; </span></span><br><span class="line">REAL dashVals[<span class="number">4</span>] = &#123;<span class="number">5.0</span>f, <span class="number">2.0</span>f, <span class="number">15.0</span>f, <span class="number">4.0</span>f&#125;<span class="comment">;</span></span><br><span class="line">for (<span class="name">int</span> i = <span class="number">0</span><span class="comment">; i &amp;lt;= 5; i++) </span></span><br><span class="line">&#123;</span><br><span class="line">    pen.SetDashStyle((<span class="name">DashStyle</span>)i)<span class="comment">;</span></span><br><span class="line">    if (<span class="name">i</span> == <span class="number">5</span>) </span><br><span class="line">        pen.SetDashPattern(<span class="name">dashVals</span>, <span class="number">4</span>)<span class="comment">;</span></span><br><span class="line">    graph.DrawLine(<span class="name">&amp;pen</span>, <span class="number">10</span>, <span class="number">10</span> + i * 20, 400, 10 + i * <span class="number">20</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="../img/gdip-编程基础/Image_041.jpg" alt="image"></p>
<p>DashCapRound 圆虚线帽</p>
<p><img src="../img/gdip-编程基础/Image_042.jpg" alt="image"></p>
<p>DashCapFlat 平虚线帽</p>
<p><img src="../img/gdip-编程基础/Image_043.jpg" alt="image"></p>
<p>DashCapTriangle 三角虚线帽 </p>
<p>图 14-26 虚线帽</p>
<p>（5）线连接</p>
<p>笔的线连接（join）属性，也是 GDI+新增的功能。可以使用 Pen 类的方法：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Status SetLineJoin( <span class="name">LineJoin</span> lineJoin)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>来设置笔的线连接属性。其中输入参数为枚举类型 LineJoin： </p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">LineJoin</span> &#123;</span></span><br><span class="line">    LineJoinMiter = <span class="number">0</span>, <span class="regexp">//</span> 斜接（默认值）</span><br><span class="line">    LineJoinBevel = <span class="number">1</span>, <span class="regexp">//</span> 斜截</span><br><span class="line">    LineJoinRound = <span class="number">2</span>, <span class="regexp">//</span> 圆角</span><br><span class="line">    LineJoinMiterClipped = <span class="number">3</span> /<span class="regexp">/ 斜剪</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>例如（参见图 14-27）：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Graphics graph(<span class="name">pDC-&amp;gt</span><span class="comment">;m_hDC); </span></span><br><span class="line">Pen pen(<span class="name">Color</span>:<span class="symbol">:DarkGreen</span>, <span class="number">40</span>)<span class="comment">; </span></span><br><span class="line">for (<span class="name">int</span> i = <span class="number">0</span><span class="comment">; i &amp;lt; 4; i++) </span></span><br><span class="line">&#123;</span><br><span class="line">    pen.SetLineJoin((<span class="name">LineJoin</span>)i)<span class="comment">;</span></span><br><span class="line">    graph.DrawRectangle(<span class="name">&amp;pen</span>, <span class="number">40</span> + i * 150, 40, 100, 100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="../img/gdip-编程基础/Image_044.jpg" alt="image"></p>
<p>LineJoinMiter LineJoinBevel LineJoinRound LineJoinMiterClipped</p>
<p>斜接 斜截 圆角 斜剪 </p>
<p>图 14-27 线连接</p>
<p>从该例还看不出斜剪与斜接有什么区别，因为斜剪 LineJoinMiterClipped 主要针对交角 很小，相交部分很长的情形。在斜剪线连接方式下，可以调用 Pen 类的方法</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Status</span> SetMiterLimit(<span class="keyword">REAL</span> miterLimit);</span><br></pre></td></tr></table></figure>
<p>来设置相交部分的最大限制长度，默认是 10.0（相对于线宽的比值）。</p>
<p>对 LineJoinMiterClipped 方式的线连接，如果 miterLimit &lt; 相交部分的长度，则会截断 至线头（同斜截方式，相当于 miterLimit = 1.0）；如果 miterLimit &gt;= 相交部分的长度，则绘 制完整的相交部分。</p>
<p>但是对 LineJoinMiter 方式的线连接，如果 miterLimit &lt; 相交部分的长度，则会截断至</p>
<p>miterLimit 所指定比例的长度；如果 miterLimit &gt;= 相交部分的长度，则绘制完整的相交部分。 例如（参见图 14-28）：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Graphics graph(<span class="name">pDC-&amp;gt</span><span class="comment">;m_hDC);</span></span><br><span class="line">Pen redPen(<span class="name">Color</span>:<span class="symbol">:Red</span>)<span class="comment">; // 画细线的红笔</span></span><br><span class="line">Pen pen(<span class="name">Color</span>:<span class="symbol">:DarkGreen</span>, <span class="number">40.0</span>f)<span class="comment">; // 画粗线的绿色笔</span></span><br><span class="line">Point points[] = &#123;Point(<span class="number">20</span>, <span class="number">100</span>), Point(<span class="number">400</span>, <span class="number">130</span>),</span><br><span class="line">Point(<span class="number">20</span>, <span class="number">160</span>)&#125;<span class="comment">; // 点数组</span></span><br><span class="line">pen.SetLineJoin(<span class="name">LineJoinMiter</span>)<span class="comment">; // 斜接</span></span><br><span class="line">//pen.SetLineJoin(<span class="name">LineJoinBevel</span>)<span class="comment">; // 斜截</span></span><br><span class="line">//pen.SetLineJoin(<span class="name">LineJoinRound</span>)<span class="comment">; // 圆角</span></span><br><span class="line">//pen.SetLineJoin(<span class="name">LineJoinMiterClipped</span>)<span class="comment">; // 斜剪</span></span><br><span class="line">//pen.SetMiterLimit(<span class="number">20.0</span>f)<span class="comment">; // 设置斜接限长 </span></span><br><span class="line">graph.DrawLines(<span class="name">&amp;pen</span>, points, <span class="number">3</span>)<span class="comment">; // 画粗线 </span></span><br><span class="line">graph.DrawLines(<span class="name">&amp;redPen</span>, points, <span class="number">3</span>)<span class="comment">; // 画细线</span></span><br></pre></td></tr></table></figure>
<p><img src="../img/gdip-编程基础/Image_045.png" alt="image"></p>
<p>图 14-28 小交角线连接 图 14-29 不同斜接限长下的斜接线连接 如果不断修改斜接线连接 LineJoinMiter 方式下的线长限制（0.0f~13.0f），则可得到不同</p>
<p>截断长度的斜交角。例如（参见图 14-29）： </p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">pen</span><span class="selector-class">.SetLineJoin</span>(LineJoinMiter); <span class="comment">// 斜接 </span></span><br><span class="line"><span class="selector-tag">pen</span><span class="selector-class">.SetMiterLimit</span>(<span class="number">1.0</span>f<span class="comment">/*~13.0f*/</span>); <span class="comment">// 设置斜接限长</span></span><br></pre></td></tr></table></figure>
<h3 id="1-7-2-刷"><a href="#1-7-2-刷" class="headerlink" title="1.7.2 刷"></a>1.7.2 刷</h3><p>与 GDI 中的一样，GDI+中的刷（brush）也是画填充图的工具，GDI+中也有与 GDI 相 对应的实心刷（单色刷）、条纹刷（影线刷）和纹理刷（图像刷）。不过，GDI+又新增加了 功能强大的线性渐变刷和路径渐变刷，而且还为所有这些刷各自建立了对应的类，基类是Brush（功能少）。</p>
<p><img src="../img/gdip-编程基础/Image_046.png" alt="image"></p>
<p>图 14-30 是 GDI+中各种刷类的层次结构图， 所有刷类都被定义在头文件 Gdiplus Brush.h 中。</p>
<p>（1）刷基类 Brush</p>
<p><img src="../img/gdip-编程基础/1-7-2-1.png" alt=""></p>
<p>Brush 是所有 GDI+具体刷类的基类，Brush 类没有自己的公用构造函数，属于非实例化</p>
<p>类（用户不能创建 Brush 类的对象和实例），只是定义了三个公用的方法（接口）： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Brush *<span class="title">Clone</span><span class="params">( VOID)</span> <span class="keyword">const</span></span>; <span class="comment">// 克隆，用于复制 Brush 及其派生类对象 Status </span></span><br><span class="line">GetLastStatus(VOID); <span class="comment">// 获取最后状态，返回刷对象最近的错误状态</span></span><br><span class="line"><span class="function">BrushType <span class="title">GetType</span><span class="params">(VOID)</span></span>; <span class="comment">// 获取类型，返回当前（派生）刷的类型枚举常量</span></span><br></pre></td></tr></table></figure>
<p>下面是 BrushType 枚举类型的定义（GdiplusEnums.h）：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    BrushTypeSolidColor = <span class="number">0</span>, <span class="comment">// 实心单色刷 </span></span><br><span class="line">    BrushTypeHatchFill = <span class="number">1</span>, <span class="comment">// 影线条纹填充刷 </span></span><br><span class="line">    BrushTypeTextureFill = <span class="number">2</span>, <span class="comment">// 图像纹理填充刷 </span></span><br><span class="line">    BrushTypePathGradient = <span class="number">3</span>, <span class="comment">// 路径渐变刷 </span></span><br><span class="line">    BrushTypeLinearGradient = <span class="number">4</span> <span class="comment">// 线性渐变刷</span></span><br><span class="line">&#125; BrushType;</span><br></pre></td></tr></table></figure>
<p>（2）实心刷类 SolidBrush</p>
<p>GDI+中，实心的单色刷对应于 SolidBrush 类，它只有一个构造函数：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SolidBrush(<span class="name">const</span> Color <span class="symbol">&amp;color</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>输入参数为颜色对象的引用。</p>
<p>在前面的例子中已经多次使用了 SolidBrush 类，下面再举一个画正叶曲线的例子，下面 是正叶曲线的极坐标方程及其到直角坐标系的转换公式：</p>
<p><img src="../img/gdip-编程基础/1-7-2-2.png" alt="image"></p>
<p>其中，l 为叶片长度、n 为叶片数目。</p>
<p>因为 GDI+并没有画正叶曲线的专门函数，所以需要用多边形、样条曲线或图形路径来 刻画它。可以使用填充多边形、填充封闭曲线和填充图形路径等方式来进行绘制，下面的代码使用的是填充闭基样条曲线，输出结果如图 14-31 所示。</p>
<ul>
<li><p>绘制单个正叶曲线的函数代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawLeaves</span><span class="params">(Graphics &amp;graph, <span class="keyword">const</span> Color col, Point &amp;O,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> l, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radian = <span class="number">3.14159265358979323846</span> / <span class="number">180.0</span>; </span><br><span class="line">    <span class="keyword">int</span> m = n &lt; <span class="number">5</span> ? <span class="number">21</span> : <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">int</span> N = m * n;</span><br><span class="line">    <span class="keyword">double</span> da = <span class="number">360.0</span> / N; PointF *ps = <span class="keyword">new</span> PointF[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">double</span> r = <span class="built_in">abs</span>(l * <span class="built_in">cos</span>(radian * (n * i * da)/ <span class="number">2.0</span>)), </span><br><span class="line">            x = r * <span class="built_in">cos</span>(i * da * radian),</span><br><span class="line">            y = r * <span class="built_in">sin</span>(i * da * radian);</span><br><span class="line">        ps[i].X = REAL(O.X + x);</span><br><span class="line">        ps[i].Y = REAL(O.Y + y);</span><br><span class="line">    &#125;</span><br><span class="line">    graph.FillClosedCurve(&amp;SolidBrush(col), ps, N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>绘制系列彩色正叶曲线的调用序列：</p>
</li>
</ul>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Graphics graph(<span class="name">pDC-&amp;gt</span><span class="comment">;m_hDC);</span></span><br><span class="line">Color cols[] = &#123;Color:<span class="symbol">:Aqua</span>, Color:<span class="symbol">:Aquamarine</span>, Color:<span class="symbol">:DarkBlue</span>, Color:<span class="symbol">:DarkKhaki</span>, </span><br><span class="line">    Color:<span class="symbol">:DeepPink</span>, Color:<span class="symbol">:BlueViolet</span>, Color:<span class="symbol">:Brown</span>, Color:<span class="symbol">:BurlyWood</span>, Color:<span class="symbol">:CadetBlue</span>, </span><br><span class="line">    Color:<span class="symbol">:Chartreuse</span>, Color:<span class="symbol">:Turquoise</span>, Color:<span class="symbol">:Coral</span>, Color:<span class="symbol">:CornflowerBlue</span>, </span><br><span class="line">    Color:<span class="symbol">:Crimson</span>, Color:<span class="symbol">:DarkCyan</span>&#125;<span class="comment">;</span></span><br><span class="line">bool color = true<span class="comment">; // false; </span></span><br><span class="line">for (<span class="name">int</span> i = <span class="number">0</span><span class="comment">; i &amp;lt; 15; i++)</span></span><br><span class="line">    DrawLeaves(<span class="name">graph</span>, color ? cols[i] : Color:<span class="symbol">:Green</span>,</span><br><span class="line">        Point(<span class="number">100</span> + <span class="number">200</span>* (i % 5), 100 + 200 * (<span class="name">i</span> / <span class="number">5</span>)), <span class="number">100</span>, i + <span class="number">1</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><img src="../img/gdip-编程基础/Image_048.jpg" alt="image"></p>
<p>图 14-31 彩色正叶曲线系列</p>
<p>（3）条纹刷类 HatchBrush</p>
<p>条纹是一种重复填充的小方形图案，一般为横线、竖线、斜线和小方块等构成。GDI+ 中，条纹刷（hatch brush 影线刷/阴影刷）对应于 HatchBrush 类，它也只有一个构造函数：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HatchBrush(<span class="name">HatchStyle</span> hatchStyle, const Color <span class="symbol">&amp;foreColor</span>, const Color <span class="symbol">&amp;backColor</span> = Color())<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>其中：第一个参数为条纹类型，第二个参数为前景色（条纹色），第三个参数为背景色（空隙色）。</p>
<p>GDI+中一共有 53 种条纹风格，而 GDI 中只有前 6 种。条纹风格枚举 HatchStyle 也被定 义在头文件 GdiplusEnums.h 中：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">enum HatchStyle &#123;</span><br><span class="line">    HatchStyleHor izontal, <span class="string">//</span> 0：横线</span><br><span class="line">    HatchStyleVertical, <span class="string">//</span> 1：竖线</span><br><span class="line">    HatchStyleForwardDiagonal, <span class="string">//</span> 2：正斜线</span><br><span class="line">    HatchStyleBackwardDiagonal, <span class="string">//</span> 3：反斜线</span><br><span class="line">    HatchStyleCross, <span class="string">//</span> 4：十字线</span><br><span class="line">    HatchStyleDiagonalCross, <span class="string">//</span> 5：斜十字线</span><br><span class="line">    HatchStyle05Percent, <span class="string">//</span> 6：5%</span><br><span class="line">    HatchStyle10Percent, <span class="string">//</span> 7：10%</span><br><span class="line">    <span class="string">...</span></span><br><span class="line">    HatchStyleSphere, <span class="string">//</span> 47：球面</span><br><span class="line">    HatchStyleSmallGrid, <span class="string">//</span> 48：小网格</span><br><span class="line">    HatchStyleSmallChecker Board, <span class="string">//</span> 49：小跳棋盘</span><br><span class="line">    HatchStyleLargeCheckerBoard, <span class="string">//</span> 50：大跳棋盘</span><br><span class="line">    HatchStyleOutlinedDiamond, <span class="string">//</span> 51：斜纲线</span><br><span class="line">    HatchStyleSolidDiamond, <span class="string">//</span> 52：实菱形 HatchStyleTotal, <span class="string">//</span> = 53（0 ~ 52）：条纹风格总数 HatchStyleLargeGrid = HatchStyleCross, <span class="string">//</span> 4：大网格</span><br><span class="line">    HatchStyleMin = HatchStyleHorizontal, <span class="string">//</span> 0：条纹风格最小值 HatchStyleMax = HatchStyleTotal - 1, <span class="string">//</span> 52：条纹风格最大值</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例如（参见图 14-32）：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Graphics graph(<span class="name">pDC-&amp;gt</span><span class="comment">;m_hDC); Pen pen(Color::Black);</span></span><br><span class="line">SolidBrush textBrush(<span class="name">Color</span>:<span class="symbol">:Red</span>)<span class="comment">;</span></span><br><span class="line">FontFamily fontFamily(<span class="name">L</span><span class="string">"Times New Roman"</span>)<span class="comment">; </span></span><br><span class="line">Font font(<span class="name">&amp;fontFamily</span>, <span class="number">18</span>)<span class="comment">;</span></span><br><span class="line">CString str<span class="comment">;</span></span><br><span class="line">StringFormat sfmt<span class="comment">; // 文本格式 </span></span><br><span class="line">sfmt.SetAlignment(<span class="name">StringAlignmentCenter</span>)<span class="comment">; // 水平对齐 </span></span><br><span class="line">sfmt.SetLineAlignment(<span class="name">StringAlignmentCenter</span>)<span class="comment">; // 垂直对齐</span></span><br><span class="line">int w = <span class="number">50</span>, h = <span class="number">50</span>, s = <span class="number">5</span><span class="comment">;</span></span><br><span class="line">for (<span class="name">int</span> i = <span class="number">0</span><span class="comment">; i &amp;lt; 53; i++) &#123; // 主循环</span></span><br><span class="line">    HatchBrush brush(<span class="name">HatchStyle</span>(<span class="name">i</span>), Color:<span class="symbol">:Black</span>, Color:<span class="symbol">:White</span>)<span class="comment">; </span></span><br><span class="line">    RectF rect(<span class="name">REAL</span>(<span class="name">s</span> + (<span class="name">i</span> % <span class="number">10</span>) * (w + s)),</span><br><span class="line">    REAL(s + (i / 10) * (<span class="name">h</span> + s)), REAL(<span class="name">w</span>), REAL(<span class="name">h</span>))<span class="comment">;</span></span><br><span class="line">    graph.FillRectangle(<span class="name">&amp;brush</span>, rect)<span class="comment">; // 画条纹块 </span></span><br><span class="line">    str.Format(<span class="name">L</span><span class="string">"%d"</span>, i)<span class="comment">; // 绘制数字编号的文本串： </span></span><br><span class="line">    graph.DrawString(<span class="name">str</span>, str.GetLength(), <span class="symbol">&amp;font</span>, rect,</span><br><span class="line">        <span class="symbol">&amp;sfmt</span>, <span class="symbol">&amp;textBrush</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="../img/gdip-编程基础/Image_049.jpg" alt="image"></p>
<p>图 14-32 条纹刷的条纹风格</p>
<p>与 GDI 一样，在 GDI+中也可以调整条纹刷和图像刷的起点。这需要使用图像类 Graphics 的方法 SetRenderingOrigin 来设置渲染原点为(x, y)（默认为(0, 0)）：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Status</span> SetRenderingOrigin(<span class="built_in">INT</span> x, <span class="built_in">INT</span> y);</span><br></pre></td></tr></table></figure>
<p>（4）纹理刷类 TextureBrush</p>
<p>纹理刷（texture brush）就是图像刷，它将刷中所装入的图像，在目标区域中进行平铺， 可达到纹理效果。GDI 中也有图像刷，但仅限于使用位图资源和（非常费事才能使用）BMP 文件。在 GDI+中，纹理刷所对应的是 TextureBrush 类，它有 7 个构造函数，最常用的为：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TextureBrush(<span class="name">Image*</span> image, WrapMode wrapMode = WrapModeTile)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>其中，第一个参数是图像对象的指针，第二个参数是排列方式的枚举常量（GdiplusEnums.h）：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    WrapModeTile = <span class="number">0</span>, <span class="comment">// 平铺（瓦）（默认值）</span></span><br><span class="line">    WrapModeTileFlipX = <span class="number">1</span>, <span class="comment">// 平铺且 X 向翻转（相邻列左右翻转） </span></span><br><span class="line">    WrapModeTileFlipY = <span class="number">2</span>, <span class="comment">// 平铺且 Y 向翻转（相邻行上下翻转） </span></span><br><span class="line">    WrapModeTileFlipXY = <span class="number">3</span>, <span class="comment">// 平铺且 XY 向翻转（相邻行列左右上下翻转） </span></span><br><span class="line">    WrapModeClamp = <span class="number">4</span> <span class="comment">// 不平铺（不重复，夹住）</span></span><br><span class="line">&#125; WrapMode;</span><br></pre></td></tr></table></figure>
<p>还可以用纹理刷类的下面两个方法来设置和获取刷的排列方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SetWrapMode</span><span class="params">(WrapMode wrapMode)</span></span>; <span class="function">WrapMode <span class="title">GetWrapMode</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>例如（参见图 14-33）：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Graphics graph(<span class="name">pDC-&amp;gt</span><span class="comment">;m_hDC); </span></span><br><span class="line">Image img(<span class="name">L</span><span class="string">"张东健.bmp"</span>)<span class="comment">;</span></span><br><span class="line">TextureBrush brush(<span class="name">&amp;img</span>, WrapModeTile/*FlipXY*/)<span class="comment">;</span></span><br><span class="line">//TextureBrush brush(<span class="name">&amp;img</span>, **WrapModeClamp**)<span class="comment">; </span></span><br><span class="line">RECT rect<span class="comment">;</span></span><br><span class="line">GetClientRect(<span class="name">&amp;rect</span>)<span class="comment">;</span></span><br><span class="line">graph.FillRectangle(<span class="name">&amp;brush</span>, RectF(<span class="number">0.0</span>f, <span class="number">0.0</span>f, REAL(<span class="name">rect</span>.right), REAL(<span class="name">rect</span>.bottom)))<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><img src="../img/gdip-编程基础/Image_050.jpg" alt="image"></p>
<p>平铺（WrapModeTile）</p>
<p><img src="../img/gdip-编程基础/Image_051.jpg" alt="image"></p>
<p>平铺且 X 向翻转（WrapModeTileFlipX）</p>
<p><img src="../img/gdip-编程基础/Image_052.jpg" alt="image"></p>
<p>平铺且 Y 向翻转（WrapModeTileFlipY）</p>
<p><img src="../img/gdip-编程基础/Image_053.jpg" alt="image"></p>
<p>平铺且 XY 向翻转（WrapModeTileFlipXY）</p>
<p><img src="../img/gdip-编程基础/Image_054.jpg" alt="image"></p>
<p>不平铺（WrapModeClamp） </p>
<p>图 14-33 纹理刷排列方式</p>
<p>纹理刷类 TextureBrush 中，还有几个方法，可以对刷中的图像进行平移（translate）、旋 转（rotate）和缩放（scale）等变换（transform）（这是 GDI 里所没有的功能）：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Status TranslateTransform(REAL dx, REAL dy, MatrixOrder <span class="keyword">order</span> <span class="title">= MatrixOrderPrepend</span>); </span><br><span class="line">Status RotateTransform(REAL angle, MatrixOrder <span class="keyword">order</span> <span class="title">= MatrixOrderPrepend</span>) ;</span><br><span class="line">Status ScaleTransform(REAL sx, REAL sy, MatrixOrder <span class="keyword">order</span> <span class="title">= MatrixOrderPrepend</span>);</span><br></pre></td></tr></table></figure>
<p>例如（参见图 14-34）：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Graphics graph(<span class="name">pDC-&amp;gt</span><span class="comment">;m_hDC); Image img(L"张东健.bmp"); </span></span><br><span class="line">TextureBrush brush(<span class="name">&amp;img</span>)<span class="comment">;</span></span><br><span class="line">//brush.TranslateTransform(<span class="number">30</span>, <span class="number">30</span>)<span class="comment">; // 平移(30, 30)</span></span><br><span class="line">brush.RotateTransform(<span class="number">30</span>)<span class="comment">; // 旋转 30 度</span></span><br><span class="line">//brush.ScaleTransform(<span class="number">3</span>, <span class="number">1</span>)<span class="comment">; // 水平放大 3 倍</span></span><br><span class="line">//brush.ScaleTransform(<span class="number">1</span>, <span class="number">3</span>)<span class="comment">; // 垂直放大 3 倍</span></span><br><span class="line">RECT rect<span class="comment">; </span></span><br><span class="line">GetClientRect(<span class="name">&amp;rect</span>)<span class="comment">;</span></span><br><span class="line">graph.FillRectangle(<span class="name">&amp;brush</span>, RectF(<span class="number">0.0</span>f, <span class="number">0.0</span>f, REAL(<span class="name">rect</span>.right), REAL(<span class="name">rect</span>.bottom)))<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><img src="../img/gdip-编程基础/Image_055.jpg" alt="image"></p>
<p>平移(30, 30)</p>
<p><img src="../img/gdip-编程基础/Image_056.jpg" alt="image"></p>
<p>旋转 30 度</p>
<p><img src="../img/gdip-编程基础/Image_057.jpg" alt="image"></p>
<p>水平放大 3 倍</p>
<p><img src="../img/gdip-编程基础/Image_058.jpg" alt="image"></p>
<p>垂直放大 3 倍</p>
<p>图 14-34 纹理刷变换</p>
<p>（5）线性渐变刷类 LinearGradientBrush</p>
<p>线性渐变刷（linear gradient brush 线性梯度刷）使用逐渐变化的颜色填充目标区域。是 GDI+新增的功能。线性渐变刷所对应的类为 LinearGradientBrush，它有 6 个构造函数，前 3 个是整数版，后 3 个是对应的浮点数版。下面是 3 个整数版的构造函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LinearGradientBrush(<span class="keyword">const</span> Point&amp; point1, <span class="keyword">const</span> Point&amp; point2, <span class="keyword">const</span> Color&amp; color1, <span class="keyword">const</span> Color&amp; color2);</span><br><span class="line">LinearGradientBrush(<span class="keyword">const</span> Rect&amp; rec t, <span class="keyword">const</span> Color&amp; color1, <span class="keyword">const</span> Color&amp; color2, LinearGradientMode mode);</span><br><span class="line">LinearGradientBrush(<span class="keyword">const</span> Rect&amp; rect, <span class="keyword">const</span> Color&amp; color1, <span class="keyword">const</span> Color&amp; color2, REAL angle, <span class="built_in">BOOL</span> is AngleScalable = <span class="literal">FALSE</span>);</span><br></pre></td></tr></table></figure>
<p>在这三种构造函数中，第一个是点到点、第二个是矩形与渐变模式、第三个是是矩形与旋转角度。限于篇幅，这里只介绍其中点到点的整数版构造函数的具体使用方法。</p>
<p>1）点到点渐变</p>
<p>点到点的渐变是指刷子所填充的颜色，沿着点 point1 到点 point2 的直线，从颜色 color1 连续变化到 color2。若 p1 和 p2 点的 y 值相等，则为水平方向的渐变；若 p1 和 p2 点的 x 值 相等，则为垂直方向的渐变；p1 和 p2 点的 x 和 y 值都不相等，则为斜对角方向的渐变。</p>
<p>例如（参见图 14-35）：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Graphics graph(pDC-&gt;m_hDC);</span><br><span class="line">Point p1(<span class="number">10</span>, <span class="number">10</span>), p2(<span class="number">110</span>, <span class="number">10</span>), p3(<span class="number">10</span>, <span class="number">110</span>), p4(<span class="number">230</span>, <span class="number">10</span>), p5(<span class="number">330</span>, <span class="number">110</span>);</span><br><span class="line">Size size(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">Color col1(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), col2(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">LinearGradientBrush hbrush(p1, p2, col1, col2);</span><br><span class="line">graph.FillRectangle(&amp;hbrush, Rect(p1, size)); </span><br><span class="line">LinearGradientBrush vbrush(p1, p3, col1, col2); </span><br><span class="line">graph.FillRectangle(&amp;vbrush, Rect(Point(<span class="number">120</span>, <span class="number">10</span>), size)); </span><br><span class="line">LinearGradientBrush dbrush(p4, p5, col1, col2); </span><br><span class="line">graph.FillRectangle(&amp;dbrush, Rect(Point(<span class="number">230</span>, <span class="number">10</span>), size));</span><br></pre></td></tr></table></figure>
<p><img src="../img/gdip-编程基础/Image_059.jpg" alt="image"></p>
<p>水平渐变 垂直渐变 对角渐变 </p>
<p>图 14-35 线性渐变刷</p>
<p>其实，线性渐变刷默认是按 WrapModeTile 平铺方式重复排列的（原点是 point1），例如（参见图 14-36 a））：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Graphics graph(<span class="name">pDC-&amp;gt</span><span class="comment">;m_hDC);</span></span><br><span class="line">Point p1(<span class="number">10</span>, <span class="number">10</span>), p2(<span class="number">110</span>, <span class="number">10</span>), p3(<span class="number">10</span>, <span class="number">110</span>)<span class="comment">;</span></span><br><span class="line">Color col1(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), col2(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>)<span class="comment">; </span></span><br><span class="line">LinearGradientBrush hbrush(<span class="name">p1</span>, p2, col1, col2)<span class="comment">;</span></span><br><span class="line">//hbrush.SetWrapMode(<span class="name">WrapModeTileFlipX</span>)<span class="comment">; </span></span><br><span class="line">graph.FillRectangle(<span class="name">&amp;hbrush</span>, Rect(<span class="name">p1</span>, Size(<span class="number">400</span>, <span class="number">200</span>)))<span class="comment">; </span></span><br><span class="line">LinearGradientBrush vbrush(<span class="name">p1</span>, p3, col1, col2)<span class="comment">;</span></span><br><span class="line">//vbrush.SetWrapMode(<span class="name">WrapModeTileFlipX</span>)<span class="comment">; </span></span><br><span class="line">graph.FillRectangle(<span class="name">&amp;vbrush</span>, Rect(<span class="name">Point</span>(<span class="number">420</span>, <span class="number">10</span>), Size(<span class="number">200</span>, <span class="number">410</span>)))<span class="comment">;</span></span><br><span class="line">LinearGradientBrush dbrush(<span class="name">p1</span>, Point(<span class="number">110</span>, <span class="number">100</span>), col1, col2)<span class="comment">;</span></span><br><span class="line">//dbrush.SetWrapMode(<span class="name">WrapModeTileFlipX</span>)<span class="comment">; </span></span><br><span class="line">graph.FillRectangle(<span class="name">&amp;dbrush</span>, Rect(<span class="name">Point</span>(<span class="number">10</span>, <span class="number">220</span>), Size(<span class="number">400</span>, <span class="number">200</span>)))<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>你也可以将上面代码中的注释符“//”去掉，利用线性渐变刷类的方法</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Status SetWrapMode(<span class="name">WrapMode</span> wrapMode)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>来设置画刷的排列方式为 WrapModeTileFlipX 平铺并水平翻转，参见图 14-36 b)。</p>
<p><img src="../img/gdip-编程基础/Image_060.jpg" alt="image"></p>
<p>图 14-37 参数的含义</p>
<p><img src="../img/gdip-编程基础/Image_061.jpg" alt="image"></p>
<p>a) 平铺重复排列 b) 加水平翻转 </p>
<p>图 14-36 按平铺重复排列的线性渐变刷</p>
<p>下面是一个利用水平线性渐变刷来画阴阳八卦中的阴阳鱼例子（参见图 14-37 和图 14-38）：</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LinearGradientBrush R2BBrush(Point(<span class="number">0</span>, <span class="number">10</span>), Point(<span class="number">200</span>, <span class="number">10</span>), Color(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>));</span><br><span class="line">LinearGradientBrush B2YBrush(Point(<span class="number">0</span>, <span class="number">10</span>), Point(<span class="number">200</span>, <span class="number">10</span>),</span><br><span class="line">Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), Color(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>));</span><br><span class="line">Pen bluePen(Color(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>));</span><br><span class="line">Rect circleRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">Rect leftRect(<span class="number">0</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">Rect rightRect(<span class="number">100</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>); Graphics graph(pDC-&amp;gt;m_hDC);</span><br><span class="line">graph.FillPie(&amp;R2BBrush, circleRect, <span class="number">0.0</span>f, <span class="number">180.0</span>f);</span><br><span class="line">graph.FillPie(&amp;B2YBrush, circleRect, <span class="number">180.0</span>f, <span class="number">180.0</span>f); </span><br><span class="line">graph.FillPie(&amp;R2BBrush, leftRect, <span class="number">180.0</span>f, <span class="number">180.0</span>f); </span><br><span class="line">graph.FillPie(&amp;B2YBrush, rightRect, <span class="number">0.0</span>f, <span class="number">180.0</span>f); int r = <span class="number">10</span>;</span><br><span class="line">graph.FillEllipse(&amp;SolidBrush(Color(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>)), <span class="number">50</span> - r, <span class="number">100</span> - r, <span class="number">2</span> * r, <span class="number">2</span> * r);</span><br><span class="line">graph.FillEllipse(&amp;SolidBrush(Color(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>)), <span class="number">150</span> - r, <span class="number">100</span> - r, <span class="number">2</span> * r, <span class="number">2</span> * r);</span><br></pre></td></tr></table></figure>
<p><img src="../img/gdip-编程基础/Image_062.jpg" alt="image"></p>
<p><img src="../img/gdip-编程基础/Image_063.jpg" alt="image"></p>
<p><img src="../img/gdip-编程基础/Image_064.png" alt="image"></p>
<p><img src="../img/gdip-编程基础/Image_065.jpg" alt="image"></p>
<p>图 14-38 绘制阴阳鱼的分步输出结果</p>
<p>2）多色渐变 线性渐变刷还有很多其他功能，例如可利用刷的方法：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Status</span> SetInterpolationColors(const Color *presetColors, const <span class="keyword">REAL</span> *blendPositions, <span class="built_in">INT</span> <span class="built_in">count</span>);</span><br></pre></td></tr></table></figure>
<p>来设置多色渐变。其中，presetColors 为多色数组、blendPositions 为以百分比表示的对应混色点的位置（首、尾值必须为 0.0f 和 1.0f，中间的值应该按递增序排列）、count 为颜色和混 色点位的数目。例如（参见图 14-39）：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Color cols[] = &#123;Color::Red, Color::<span class="keyword">Orange, </span>Color::Yellow, Color::Green, Color::Cyan, Color::<span class="keyword">Blue, </span>Color::Purple, Color::Magenta&#125;<span class="comment">;</span></span><br><span class="line">REAL <span class="keyword">bps[] </span>= &#123;<span class="number">0</span>.<span class="number">0</span>f, <span class="number">0</span>.<span class="number">15</span>f, <span class="number">0</span>.<span class="number">3</span>f, <span class="number">0</span>.<span class="number">45</span>f, <span class="number">0</span>.<span class="number">6</span>f, <span class="number">0</span>.<span class="number">75</span>f, <span class="number">0</span>.<span class="number">875</span>f, <span class="number">1</span>.<span class="number">0</span>f&#125;<span class="comment">;</span></span><br><span class="line">LinearGradientBrush <span class="keyword">brush(Point(10, </span><span class="number">10</span>), Point(<span class="number">810</span>, <span class="number">10</span>), Color::<span class="keyword">Black, </span>Color::White)<span class="comment">;</span></span><br><span class="line"><span class="keyword">brush.SetInterpolationColors(cols, </span><span class="keyword">bps, </span><span class="number">8</span>)<span class="comment">;</span></span><br><span class="line">graph.FillRectangle(&amp;<span class="keyword">brush, </span>Rect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">800</span>, <span class="number">100</span>))<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><img src="../img/gdip-编程基础/Image_066.jpg" alt="image"></p>
<p>图 14-39 多色渐变 另外，也可以像纹理刷和条纹刷一样，设置线性渐变刷的渲染原点等。 路径渐变刷的内容，安排到下一章的第 15.1.2 小节中，在介绍过路径的基本概念和使用方法之后再来讲解。</p>
<h2 id="1-8-文字"><a href="#1-8-文字" class="headerlink" title="1.8 文字"></a>1.8 文字</h2><p>GDI+的文本排版和字体处理的功能比 GDI 的更加强大。特别是 Windows XP 及以上版本，提供了对 LCD（液晶）显示器的特殊优化功能，GDI+也提供了对应的 ClearType（清晰活字）文字处理技术，以增强字体的清晰度。另外，GDI+还提供了构造专用字体集的功能，可以包含私有的临时字体（不需预先安装到系统中）。</p>
<p>Windows 中使用的字体，一般是 TrueType（真实活字） 字体（TTF=TrueType Font），它是 1991 年 Apple 和 Microsoft 联合开发的一种字体技术，采用二次贝塞尔曲线来描述字符 的轮廓。</p>
<p><img src="../img/gdip-编程基础/1-8-1.png" alt=""></p>
<p>在 GDI+中，与文字相关的类有（参见图 14-40）：字体族类 FontFamily、字体类 Font 和字体集类 FontCollection 及其两个派生类 InstalledFontCollection （已安装字体集）和 PrivateFontCollection（专用字体集）。而在 GDI 中，则只有 CFont 一个字体类。</p>
<p>图 14-40 字体类的层次结构</p>
<h3 id="1-8-1-字体"><a href="#1-8-1-字体" class="headerlink" title="1.8.1 字体"></a>1.8.1 字体</h3><p>下面介绍字体族类 FontFamily 和字体类 Font 及相关参数。</p>
<p>（1）字体族类 FontFamily</p>
<p>字体族（font family）是一组具有同一字样（typeface），但是风格（style）不同的字体（font）。其中，字样是指字体的种类，如 Arial、Times New Roman、宋体、楷体_GB2312。 风格是指：正常（regular）、粗体（bold）、斜体（italic）、粗斜体（bold and italic）、下划线（underline）、删除线（strikeout）等。</p>
<p>1）构造函数</p>
<p>字体族类 FontFamily 有两个构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FontFamily( VOID); <span class="comment">// 构造一个空字体族（少用）</span></span><br><span class="line"><span class="comment">// 构造具有指定名称 name，位于指定字体集 fontCollection 中的字体族</span></span><br><span class="line">FontFamily(<span class="keyword">const</span> WCHAR *name, <span class="keyword">const</span> FontCollection *fontCollection = <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>只要不是使用专用字体集中的字体，一般不需要设置第二个输入参数，取默认的 NULL 即可。例如：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FontFamily fontFamily(<span class="name">L</span><span class="string">"宋体"</span>)<span class="comment">; 或</span></span><br><span class="line">FontFamily fontFamily(<span class="name">L</span><span class="string">"Times New Roman"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>2）显示当前系统已装入的字体（族）名称</p>
<p>可先利用（字体集 FontCollection 的派生类）已安装字体集类 InstalledFontCollection 的 方法 GetFamilyCount 和 GetFamilies 来分别获取当前系统中已经安装字体集中字体族的数目 和对象指针：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">INT</span> GetFamilyCount( VOID) <span class="keyword">const</span><span class="comment">;</span></span><br><span class="line">Status GetFamilies(<span class="built_in">INT</span> numSought, FontFamily *gpfamilies, <span class="built_in">INT</span> *numFound) <span class="keyword">const</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>然后再利用字体族类的方法 GetFamilyName 来获取每个字体族的名称：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetFamilyName</span><span class="params">(WCHAR name[LF_FACESIZE], WCHAR language = LANG_NEUTRAL)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中 LANG_NEUTRAL 表示采用中立语言，即用户的默认语言。</p>
<p>例如（可创建一个带滚动视图类的单文档 MFC 应用程序 Fonts，添加对 GDI+的支持， 输出结果如图 14-41 所示）：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void CFontsView::OnDraw(CDC* pDC) &#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="keyword">InstalledFontCollection </span>ifc<span class="comment">; int n = ifc.GetFamilyCount();</span></span><br><span class="line">    FontFamily *ffs = new FontFamily[n]<span class="comment">;</span></span><br><span class="line">    int found<span class="comment">;</span></span><br><span class="line">    ifc.GetFamilies(n, ffs, &amp;found)<span class="comment">; wchar_t name[LF_FACESIZE];</span></span><br><span class="line">    Font font(L<span class="string">"宋体"</span>, <span class="number">18</span>)<span class="comment">;</span></span><br><span class="line">    SolidBrush textBrush(Color::<span class="keyword">Black); </span></span><br><span class="line">    Graphics graph(pDC-&amp;gt<span class="comment">;m_hDC); wchar_t str[40];</span></span><br><span class="line">    <span class="keyword">swprintf_s(str, </span><span class="number">40</span>, L<span class="string">"当前系统中，总共装有如下%d 种字体："</span>, n)<span class="comment">;</span></span><br><span class="line">    graph.DrawString(str, INT(wcslen(str)), &amp;font, PointF(<span class="number">10</span>.<span class="number">0</span>f, <span class="number">10</span>.<span class="number">0</span>f), &amp;textBrush)<span class="comment">;</span></span><br><span class="line">    for (int i = <span class="number">0</span><span class="comment">; i &amp;lt; n; i++) &#123; </span></span><br><span class="line">        ffs[i].**GetFamilyName**(name)<span class="comment">; </span></span><br><span class="line">        graph.DrawString(name, INT(wcslen(name)), &amp;font,</span><br><span class="line">            PointF(<span class="number">10</span>.<span class="number">0</span>f, <span class="number">80</span>.<span class="number">0</span>f + <span class="number">40</span> * i), &amp;textBrush)<span class="comment">; </span></span><br><span class="line">        graph.DrawString(L<span class="string">"Font Family 字体族"</span>, <span class="number">15</span>,</span><br><span class="line">            &amp;Font(name, <span class="number">18</span>),</span><br><span class="line">            PointF(<span class="number">300</span>.<span class="number">0</span>f, <span class="number">80</span>.<span class="number">0</span>f + <span class="number">40</span> * i), &amp;textBrush)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="../img/gdip-编程基础/Image_068.jpg" alt="image"></p>
<p>图 14-41 获取并显示当前系统的字体</p>
<p>注：如果想用程序将这些名称写入一个文本文件，需要注意 ofstream 不支持宽字符串的 流输出，可以用实例模板类 of<strong>w</strong>stream 来定义一个新的文件输出流类型。还可以采用 CFile 来输出，但要注意宽字符串采用的是 UTF-16 编码，需要在文本文件的开始处，添加用 0xFE 和 0xFF 这两个字节表示的 UTF-16 编码标志。</p>
<p>（2）字体类 Font</p>
<p>字体类 Font 的构造函数有 6 个，常用的是如下两个：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Font(const FontFamily *family, <span class="keyword">REAL</span> emSize, <span class="built_in">INT</span> style = FontStyleRegular, <span class="keyword">Unit</span> <span class="keyword">unit</span> = UnitPoint);</span><br><span class="line">Font(const WCHAR *familyName, <span class="keyword">REAL</span> emSize, <span class="built_in">INT</span> style = FontStyleRegular, <span class="keyword">Unit</span> <span class="keyword">unit</span> = UnitPoint, const FontCollection *fontCollection = NULL);</span><br></pre></td></tr></table></figure>
<p>其中的第一个构造函数，其第一个输入参数是字体族的指针，所以必须先创建字体族对象。</p>
<p>而第 2 个构造函数的第一个输入参数则是字体族（字样）的名称，不需要创建字体族对象， 并且还多了可以选择的字体集作为最后一个输入参数。其余的构造函数都与 API 中的字体 句柄、逻辑结构和 DC 中的当前字体有关，在 GDI 中已经讨论过。</p>
<p>注意：在使用 VC08 SP1 和 VC10 时，需要注释掉（默认）位于 c:\program files\microsoft visual studio 9.0\vc\include\目录中的 VC 头文件 comdef.h 中的第 309~315 行：</p>
<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// hard-coded smart pointer defs</span><br><span class="line">/*<span class="comment">#if defined( IFontDisp_INTERFACE_DEFINED )</span></span><br><span class="line">if_not_exists(Font)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Font</span> : IFontDisp </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">_COM_SMARTPTR_TYPEDEF(Font, uuidof(IDispatch));</span><br><span class="line"><span class="comment">#endif*/</span></span><br></pre></td></tr></table></figure>
<p>不然，编译时会出现两个 Font 类定义冲突问题的错误。也可以不改 comdef.h，而在代码中 的每个 Font 类名的前面，都加上命名空间限定符“Gdiplus::”，如 Gdiplus::Font，不过这样 又太麻烦。</p>
<p>下面我们重点讨论第二个构造函数的使用，先介绍其中的各个参数。</p>
<p>1）字体种类 familyName（字体族名）—— 宽字符串表示的字体名称</p>
<ul>
<li><p>常用的英文字体族名有：</p>
<ul>
<li>Times New Roman：Font Family Name 字体族名(有衬线)</li>
<li>Arial： Font Family Name 字体族名(无衬线)</li>
<li>Arial Narrow： Font Family Name 字体族名(窄体)</li>
<li>Courier New： Font Family Name 字体族名(等宽)</li>
</ul>
</li>
<li><p>常用的中文字体族名有：</p>
<ul>
<li>宋体： Font Family Name 字体族名(正文)</li>
<li>楷体_GB2312： Font Family Name 字体族名(正文、标题)</li>
<li>黑体： Font Family Name 字体族名(标题、美术)</li>
<li>仿宋_GB2312： Font Family Name 字体族名(标题、美术)</li>
<li>隶书： Font Family Name 字体族名(标题、美术)</li>
</ul>
</li>
</ul>
<p>2）字体风格 style—— 字体的风格，可以取如下枚举常量（默认为 FontStyleRegular）： </p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    FontStyleRegular = <span class="number">0</span>, <span class="comment">// 正常（默认值）</span></span><br><span class="line">    FontStyleBold = <span class="number">1</span>, <span class="comment">// 粗体 </span></span><br><span class="line">    FontStyleItalic = <span class="number">2</span>, <span class="comment">// 斜体 </span></span><br><span class="line">    FontStyleBoldItalic = <span class="number">3</span>, <span class="comment">// 粗斜体 </span></span><br><span class="line">    FontStyleUnderline = <span class="number">4</span>, <span class="comment">// 下划线</span></span><br><span class="line">    FontStyleStrikeout = <span class="number">8</span> <span class="comment">// 删除线</span></span><br><span class="line">&#125; FontStyle;</span><br></pre></td></tr></table></figure>
<p>3）字体单位 unit 与大小 emSize——字体的大小与有单位关，可用单位有： </p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    UnitWor ld = <span class="number">0</span>, <span class="comment">// 逻辑单位（非物理单位，默认为像素）</span></span><br><span class="line">    UnitDisplay = <span class="number">1</span>, <span class="comment">// 设备单位，如对显示器为像素、对打印机为墨点 </span></span><br><span class="line">    UnitPixel = <span class="number">2</span>, <span class="comment">// 像素（1/54 或 1/96 英寸？与屏幕大小和分辨率有关） </span></span><br><span class="line">    UnitPoint = <span class="number">3</span>, <span class="comment">// 点或 1/72 英寸（默认值）</span></span><br><span class="line">    UnitInch = <span class="number">4</span>, <span class="comment">// 英寸 </span></span><br><span class="line">    UnitDocument = <span class="number">5</span>,../<span class="number">300</span> 英寸 </span><br><span class="line">    UnitMillimeter = <span class="number">6</span> <span class="comment">// 毫米 mm</span></span><br><span class="line">&#125; Unit;</span><br></pre></td></tr></table></figure>
<p>其中，em = M，在印刷行业中表示一个西文印刷符号的全长或全宽。</p>
<p>在 GDI 的 CFont 部分，已经介绍了中文字号与英文磅数（相当于这里的 UnitPoint 点值） 的关系，表 14-1 列出了中文字号与几种主要 Unit 单位的关系（设 1 像素=1/54 英寸）。</p>
<p>表 14-1 中文字号与 Unit 单位的关系</p>
<table>
<thead>
<tr>
<th>汉字字号</th>
<th>Pixel像素</th>
<th>Point点</th>
<th>Inch英寸</th>
<th>Document文档</th>
<th>Millimeter毫米</th>
</tr>
</thead>
<tbody>
<tr>
<td>特号</td>
<td>133.33</td>
<td>100</td>
<td>1.39</td>
<td>416.67</td>
<td>35.28</td>
</tr>
<tr>
<td>小特</td>
<td>80</td>
<td>60</td>
<td>0.83</td>
<td>250</td>
<td>21.17</td>
</tr>
<tr>
<td>初号</td>
<td>56</td>
<td>42</td>
<td>0.58</td>
<td>175</td>
<td>14.82</td>
</tr>
<tr>
<td>小初</td>
<td>48</td>
<td>36</td>
<td>0.5</td>
<td>150</td>
<td>12.7</td>
</tr>
<tr>
<td>一号</td>
<td>34.67</td>
<td>26</td>
<td>0.36</td>
<td>108.33</td>
<td>9.17</td>
</tr>
<tr>
<td>小一</td>
<td>32</td>
<td>24</td>
<td>0.33</td>
<td>100</td>
<td>8.47</td>
</tr>
<tr>
<td>二号</td>
<td>29.33</td>
<td>22</td>
<td>0.31</td>
<td>91.67</td>
<td>7.76</td>
</tr>
<tr>
<td>小二</td>
<td>24</td>
<td>18</td>
<td>0.25</td>
<td>75</td>
<td>6.35</td>
</tr>
<tr>
<td>三号</td>
<td>21.33</td>
<td>16</td>
<td>0.22</td>
<td>66.67</td>
<td>5.64</td>
</tr>
<tr>
<td>小三</td>
<td>20</td>
<td>15</td>
<td>0.21</td>
<td>62.5</td>
<td>5.29</td>
</tr>
<tr>
<td>四号</td>
<td>18.67</td>
<td>14</td>
<td>0.19</td>
<td>58.33</td>
<td>4.94</td>
</tr>
<tr>
<td>小四</td>
<td>16</td>
<td>12</td>
<td>0.17</td>
<td>50</td>
<td>4.23</td>
</tr>
<tr>
<td>五号</td>
<td>14</td>
<td>10.5</td>
<td>0.15</td>
<td>43.75</td>
<td>3.70</td>
</tr>
<tr>
<td>小五</td>
<td>12</td>
<td>9</td>
<td>0.125</td>
<td>37.5</td>
<td>3.175</td>
</tr>
<tr>
<td>六号</td>
<td>10</td>
<td>7.5</td>
<td>0.10</td>
<td>31.25</td>
<td>2.65</td>
</tr>
<tr>
<td>小六</td>
<td>8.67</td>
<td>6.5</td>
<td>0.09</td>
<td>27.08</td>
<td>2.29</td>
</tr>
<tr>
<td>七号</td>
<td>7.33</td>
<td>5.5</td>
<td>0.08</td>
<td>22.92</td>
<td>1.94</td>
</tr>
<tr>
<td>八号</td>
<td>6.67</td>
<td>5</td>
<td>0.07</td>
<td>20.83</td>
<td>1.76</td>
</tr>
</tbody>
</table>
<p>例如（参见图 14-42）：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">REAL fs[] = &#123;<span class="number">100</span>, <span class="number">60</span>, <span class="number">42</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">24</span>, <span class="number">22</span>, <span class="number">18</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">12</span>,</span><br><span class="line">    <span class="number">10.5</span>, <span class="number">9</span>, <span class="number">7.5</span>, <span class="number">6.5</span>, <span class="number">5.5</span>, <span class="number">5</span>&#125;;</span><br><span class="line">CString fno[] = &#123;L<span class="string">"特"</span>, L<span class="string">"小特"</span>, L<span class="string">"初"</span>, L<span class="string">"小初"</span>, L<span class="string">"一"</span>,</span><br><span class="line">    L<span class="string">"小一"</span>, L<span class="string">"二"</span>, L<span class="string">"小二"</span>, L<span class="string">"三"</span>, L<span class="string">"小三"</span>, L<span class="string">"四"</span>, L<span class="string">"小四"</span>,</span><br><span class="line">    L<span class="string">"五"</span>, L<span class="string">"小五"</span>, L<span class="string">"六"</span>, L<span class="string">"小六"</span>, L<span class="string">"七"</span>, L<span class="string">"八"</span>&#125;;</span><br><span class="line">wchar_t <span class="built_in">str</span>[<span class="number">100</span>]; REAL <span class="built_in">size</span>, y = <span class="number">10.0</span>f;</span><br><span class="line">SolidBrush textBrush(Color::Black); </span><br><span class="line">Graphics graph(pDC-&gt;m_hDC);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &amp;lt; <span class="number">18</span>; i++) &#123; </span><br><span class="line">    <span class="built_in">size</span> = fs[i]; swprintf_s(<span class="built_in">str</span>, <span class="number">100</span>,</span><br><span class="line">        L<span class="string">"这是%s 号字(%.4g 像素 %g 点 %.4g 英寸 %.4g 文档 %.4g 毫米)"</span>,</span><br><span class="line">        fno[i], <span class="built_in">size</span> * <span class="number">4</span> / <span class="number">3.0</span>, <span class="built_in">size</span>, <span class="built_in">size</span> / <span class="number">72.0</span>,</span><br><span class="line">        <span class="built_in">size</span> * <span class="number">300</span> / <span class="number">72.0</span>, <span class="built_in">size</span> / <span class="number">72.0</span> * <span class="number">25.4</span>); </span><br><span class="line">    graph.DrawString(<span class="built_in">str</span>, INT(wcslen(<span class="built_in">str</span>)),</span><br><span class="line">        &amp;Font(L<span class="string">"宋体"</span>, <span class="built_in">size</span>), PointF(<span class="number">10.0</span>f, y), &amp;textBrush);</span><br><span class="line">    y += <span class="built_in">size</span> * <span class="number">1.5</span>f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="../img/gdip-编程基础/Image_069.jpg" alt="image"></p>
<p>图 14-42 中文字号与 Unit 单位</p>
<h3 id="1-8-2-绘制文本"><a href="#1-8-2-绘制文本" class="headerlink" title="1.8.2 绘制文本"></a>1.8.2 绘制文本</h3><p>在 GDI 中，我们用 CDC 类的方法 TextOut、DrawText 和 ExtTextOut 等来输出文本串。 在 GDI+中，我们则是利用 Graphics 类的重载方法 DrawString 来绘制文本。</p>
<p>（1）画串方法 DrawString</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Status DrawString(<span class="keyword">const</span> WCHAR *<span class="built_in">string</span>, <span class="built_in">INT</span> length, <span class="keyword">const</span> Font *font, <span class="keyword">const</span> PointF &amp;origin, <span class="keyword">const</span> Brush *brush)<span class="comment">;</span></span><br><span class="line">Status DrawString(<span class="keyword">const</span> WCHAR *<span class="built_in">string</span>, <span class="built_in">INT</span> length, <span class="keyword">const</span> Font *font, <span class="keyword">const</span> PointF &amp;origin, <span class="keyword">const</span> <span class="built_in">StringFormat</span> *<span class="built_in">stringFormat</span>, <span class="keyword">const</span> Brush *brush)<span class="comment">;</span></span><br><span class="line">Status DrawString(<span class="keyword">const</span> WCHAR *<span class="built_in">string</span>, <span class="built_in">INT</span> length, <span class="keyword">const</span> Font *font, <span class="keyword">const</span> RectF &amp;layoutRect, <span class="keyword">const</span> <span class="built_in">StringFormat</span> *<span class="built_in">stringFormat</span>, <span class="keyword">const</span> Brush *brush)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>这三个同名的 Graphics 类重载方法，都以宽字符串作为第一个输入参数（不支持普通 字符串）、串长为第二个参数（对以 null 结尾的字符串，可以使用-1 来代替）、最后一个参 数则都是绘制文本用的画刷指针。</p>
<p>不同的是第三个输入参数（都是浮点数版本，不支持整数版本）：前两个方法的是浮点 数版的点类 PointF 对象，表示文本串的位置（默认是左上角）；最后一个方法的是浮点数版 的矩形类 RectF 对象，表示绘制文本的范围（超出部分会被截掉）。</p>
<p>另 一 个不 同之 处是 ，后 两个 方法 比第 一个 方法 多了 一个 输入 参数 —— 串格 式 类 StringFormat 对象的指针，用于设置文本的对齐方式、输出方向、自动换行、制表符定制、 剪裁等。</p>
<p>第一个画串方法最简单，使用得也最多。例如：</p>
<figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph.DrawString(<span class="keyword">str</span>, <span class="keyword">INT</span>(wcslen(<span class="keyword">str</span>)), &amp;<span class="keyword">Font</span>(L<span class="string">" 宋体 "</span>, <span class="number">12</span>), PointF(<span class="number">10.0</span>f, <span class="number">10.0</span>f), &amp;brush)<span class="comment">;</span></span><br><span class="line">graph.DrawString(<span class="keyword">str</span>, <span class="number">-1</span>, &amp;<span class="keyword">font</span>, &amp;rect, &amp;stringFormat, &amp;brush)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>（2）串格式类 StringFormat</p>
<p>StringFormat 是从 Gdiplus Base 类直接派生的一个 GDI+类，用于设置绘制字符串时的各 种格式。其主要的构造函数为：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">StringFormat</span>(<span class="built_in">INT</span> formatFlags = <span class="number">0</span>, LANGID language = LANG_NEUTRAL)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>其中：</p>
<p>formatFlags（格式标志位）—— 用于设置各种输出格式，取值为 StringFormatFlags 枚举的下列常量之位或“|”：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    StringFormatFlagsDirectionRightToLeft = <span class="number">0</span>x00000001, <span class="comment">// 方向从右到左（默认为从左到右） </span></span><br><span class="line">    StringFormatFlagsDirectionVertical = <span class="number">0</span>x00000002, <span class="comment">// 垂直方向（默认为水平） </span></span><br><span class="line">    StringFormatFlagsNoFitBlackBox = <span class="number">0</span>x00000004, <span class="comment">// 允许字符尾部悬于矩形之外 </span></span><br><span class="line">    StringFormatFlagsDisplayFormatControl = <span class="number">0</span>x00000020, <span class="comment">// Unicode 布局控制符起作用 </span></span><br><span class="line">    StringFormatFlagsNoFontFallback = <span class="number">0</span>x00000400, <span class="comment">// 有替换用的“缺少字体”（默认为开方形符） </span></span><br><span class="line">    StringFormatFlagsMeasureTrailingSpaces = <span class="number">0</span>x00000800, <span class="comment">// 测量时包含尾部空格符（默认不包含）</span></span><br><span class="line">    StringFormatFlagsNoWrap = <span class="number">0</span>x00001000, <span class="comment">// 不自动换行</span></span><br><span class="line">    StringFormatFlagsLineLimit = <span class="number">0</span>x00002000, <span class="comment">// 最后一行必须为整行高，避免半行高的输出</span></span><br><span class="line">    StringFormatFlagsNoClip = <span class="number">0</span>x00004000 <span class="comment">// 不使用剪裁</span></span><br><span class="line">&#125; StringFormatFlags;</span><br></pre></td></tr></table></figure>
<p>language （语言） —— 取值为 16 位 语 言 标识 符 类 型 LANGID ， 默认 值为 LANG_NEUTRAL（语言中立），表示采用用户的默认语言。</p>
<p>（3）输出方向</p>
<p>默认的文本串输出方向是从左到右水平绘制。也可以在 StringFormat 类的构造函数中使 用参数值：StringFormatFlagsDirectionRightToLeft 和 StringFormatFlagsDirectionVertical 来修 改文本串的输出方向为从右到左水平绘制和从上到下垂直绘制。</p>
<p>（4）剪裁与换行</p>
<p>默认情况下，使用矩形输出长文本串时，会自动换行和剪裁。但是也可以在 StringFormatF 类的构造函数中，利用第一个输入参数的 StringFormatFlags 枚举值，来改变默认的设置。</p>
<p>（5）对齐</p>
<p>可以通过 StringFormat 类的方法来设置输出文本串的对齐方式： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SetAlignment</span><span class="params">(StringAlignment align)</span></span>; <span class="comment">// 设置水平对齐 </span></span><br><span class="line"><span class="function">Status <span class="title">SetLineAlignment</span><span class="params">(StringAlignment align)</span></span>; <span class="comment">// 设置垂直对齐</span></span><br></pre></td></tr></table></figure>
<p>其中的输入参数为枚举常量：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    StringAlignmentNear = <span class="number">0</span>, <span class="regexp">//</span> 靠近（左上） </span><br><span class="line">    StringAlignmentCenter = <span class="number">1</span>, <span class="regexp">//</span> 中心（对中） </span><br><span class="line">    StringAlignmentFar = <span class="number">2</span> /<span class="regexp">/ 远离（右下）</span></span><br><span class="line"><span class="regexp">&#125; StringAlignment;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-8-3-美术字"><a href="#1-8-3-美术字" class="headerlink" title="1.8.3 美术字"></a>1.8.3 美术字</h3><p>下面介绍阴影、条纹、纹理、渐变、空心字和彩心字等绘制美术字的方法，它们是利用不同颜色、条纹和渐变的画刷，以及多次绘图的方式，来实现特定美术效果的。</p>
<p>（1）阴影字</p>
<p>可以使用两种不同颜色的画刷，经过在不同的为位置多次绘制同一文本串，就可以达到 输出阴影字的效果。例如（参见图 14-43）：</p>
<figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Graphics graph(pDC-&amp;gt<span class="comment">;m_hDC);</span></span><br><span class="line">SolidBrush textBrush(<span class="keyword">Color</span>::Red), shadowBrush(<span class="keyword">Color</span>::Gray)<span class="comment">; HatchBrush hatchBrush(HatchStyleForwardDiagonal,</span></span><br><span class="line">    <span class="keyword">Color</span>::Black, <span class="keyword">Color</span>::White)<span class="comment">;</span></span><br><span class="line">CString <span class="keyword">str</span> = L<span class="string">"阴影字符串"</span><span class="comment">; </span></span><br><span class="line"><span class="keyword">Font</span> <span class="keyword">font</span>(L<span class="string">"华文新魏"</span>, <span class="number">100</span>)<span class="comment">;</span></span><br><span class="line">REAL d = <span class="number">10.0</span>f, dd = <span class="number">5.0</span>f<span class="comment">;</span></span><br><span class="line">graph.DrawString(<span class="keyword">str</span>, str.GetLength(), &amp;<span class="keyword">font</span>, PointF(d + dd, d + dd), &amp;shadowBrush)<span class="comment">;</span></span><br><span class="line">graph.DrawString(<span class="keyword">str</span>, str.GetLength(), &amp;<span class="keyword">font</span>, PointF(d, d), &amp;textBrush)<span class="comment">;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span><span class="comment">; i &amp;lt; 20; i++) </span></span><br><span class="line">    graph.DrawString(<span class="keyword">str</span>, str.GetLength(), &amp;<span class="keyword">font</span>,</span><br><span class="line">        PointF(d + i, <span class="number">150</span> + d + i + <span class="number">2</span>), &amp;hatchBrush)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><img src="../img/gdip-编程基础/Image_070.jpg" alt="image"></p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">graph.DrawString</span>(<span class="keyword">str, </span><span class="keyword">str.GetLength(), </span>&amp;font, PointF(d, <span class="number">150</span> + d), &amp;textBrush)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>图 14-43 阴影字</p>
<p>（2）条纹字</p>
<p>也可以直接利用条纹刷，来绘制条纹状的字符串。例如（参见图 14-44）：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Graphics graph(<span class="name">pDC-&amp;gt</span><span class="comment">;m_hDC); </span></span><br><span class="line">CString str = L<span class="string">"条纹字符串"</span><span class="comment">; </span></span><br><span class="line">Font font(<span class="name">L</span><span class="string">"华文新魏"</span>, <span class="number">140</span>)<span class="comment">;</span></span><br><span class="line">HatchBrush hatchBrush1(<span class="name">HatchStyleForwardDiagonal</span>, Color:<span class="symbol">:Red</span>, Color:<span class="symbol">:White</span>)<span class="comment">;</span></span><br><span class="line">graph.DrawString(<span class="name">str</span>, str.GetLength(), <span class="symbol">&amp;font</span>, PointF(<span class="number">0.0</span>f, <span class="number">0.0</span>f), <span class="symbol">&amp;hatchBrush1</span>)<span class="comment">;</span></span><br><span class="line">HatchBrush hatchBrush2(<span class="name">HatchStyleBackwardDiagonal</span>, Color:<span class="symbol">:Green</span>, Color:<span class="symbol">:White</span>)<span class="comment">;</span></span><br><span class="line">graph.DrawString(<span class="name">str</span>, str.GetLength(), <span class="symbol">&amp;font</span>, PointF(<span class="number">0.0</span>f, <span class="number">200.0</span>f), <span class="symbol">&amp;hatchBrush2</span>)<span class="comment">;</span></span><br><span class="line">HatchBrush hatchBrush3(<span class="name">HatchStyleCross</span>, Color:<span class="symbol">:Blue</span>, Color:<span class="symbol">:White</span>)<span class="comment">;</span></span><br><span class="line">graph.DrawString(<span class="name">str</span>, str.GetLength(), <span class="symbol">&amp;font</span>, PointF(<span class="number">0.0</span>f, <span class="number">400.0</span>f), <span class="symbol">&amp;hatchBrush3</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><img src="../img/gdip-编程基础/Image_071.jpg" alt="image"></p>
<p>图 14-44 条纹字</p>
<p>（3）纹理字</p>
<p>还可以利用纹理（图像）刷来绘制纹理字符串。例如（参见图 14-45）：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Graphics graph(<span class="name">pDC-&amp;gt</span><span class="comment">;m_hDC); </span></span><br><span class="line">CString str = L<span class="string">"纹理字符串"</span><span class="comment">; </span></span><br><span class="line">Font font(<span class="name">L</span><span class="string">"华文新魏"</span>, <span class="number">140</span>)<span class="comment">;</span></span><br><span class="line">TextureBrush textureBrush(<span class="name">&amp;Image</span>(<span class="name">L</span><span class="string">"张东健.bmp"</span>))<span class="comment">;</span></span><br><span class="line">graph.DrawString(<span class="name">str</span>, str.GetLength(), <span class="symbol">&amp;font</span>, PointF(<span class="number">10.0</span>f, <span class="number">10.0</span>f), <span class="symbol">&amp;textureBrush</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><img src="../img/gdip-编程基础/Image_072.jpg" alt="image"></p>
<p>图 14-45 纹理字</p>
<p>（4）渐变字</p>
<p>当然，也可以利用线性渐变刷来绘制色彩变幻的字符串。例如，使用前面的多色渐变刷 代码，可以得到很好的变色效果（参见图 14-46）：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Graphics graph(<span class="name">pDC-&amp;gt</span><span class="comment">;m_hDC); </span></span><br><span class="line">CString str = L<span class="string">"颜色渐变字符串"</span><span class="comment">; </span></span><br><span class="line">Font font(<span class="name">L</span><span class="string">"华文新魏"</span>, <span class="number">100</span>)<span class="comment">;</span></span><br><span class="line">Color cols[] = &#123;Color:<span class="symbol">:Red</span>, Color:<span class="symbol">:Orange</span>, Color:<span class="symbol">:Yellow</span>, Color:<span class="symbol">:Green</span>, Color:<span class="symbol">:Cyan</span>, Color:<span class="symbol">:Blue</span>, Color:<span class="symbol">:Purple</span>, Color:<span class="symbol">:Magenta</span>&#125;<span class="comment">;</span></span><br><span class="line">REAL bps[] = &#123;<span class="number">0.0</span>f, <span class="number">0.15</span>f, <span class="number">0.3</span>f, <span class="number">0.45</span>f, <span class="number">0.6</span>f, <span class="number">0.75</span>f, <span class="number">0.875</span>f, <span class="number">1.0</span>f&#125;<span class="comment">;</span></span><br><span class="line">LinearGradientBrush brush(<span class="name">Point</span>(<span class="number">10</span>, <span class="number">10</span>), Point(<span class="number">810</span>, <span class="number">10</span>), Color:<span class="symbol">:Black</span>, Color:<span class="symbol">:White</span>)<span class="comment">;</span></span><br><span class="line">brush.SetInterpolationColors(<span class="name">cols</span>, bps, <span class="number">8</span>)<span class="comment">; </span></span><br><span class="line">graph.DrawString(<span class="name">str</span>, str.GetLength(), <span class="symbol">&amp;font</span>, PointF(<span class="number">10.0</span>f, <span class="number">10.0</span>f), <span class="symbol">&amp;brush</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><img src="../img/gdip-编程基础/Image_073.jpg" alt="image"></p>
<p>图 14-46 渐变字</p>
<p>（5）空心字与彩心字</p>
<p>还可以利用 GDI+的路径和路径渐变刷，来绘制空心和彩心字符串。例如（参见图 14-47）：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Graphics graph(<span class="name">pDC-&amp;gt</span><span class="comment">;m_hDC); </span></span><br><span class="line">FontFamily ff(<span class="name">L</span><span class="string">"隶书"</span>)<span class="comment">; </span></span><br><span class="line">wchar_t str[] = L<span class="string">"测试字符串"</span><span class="comment">;</span></span><br><span class="line">REAL emSize = <span class="number">120</span><span class="comment">; // UnitWorld </span></span><br><span class="line">graph.DrawString(<span class="name">str</span>, <span class="number">-1</span>, <span class="symbol">&amp;Font</span>(<span class="name">L</span><span class="string">"隶书"</span>, emSize, FontStyleRegular, UnitWorld), PointF(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line"><span class="symbol">&amp;SolidBrush</span>(<span class="name">Color</span>:<span class="symbol">:Green</span>))<span class="comment">;</span></span><br><span class="line">GraphicsPath path, *pOutlinePath;</span><br><span class="line">path.AddString(str, -1, &amp;ff, FontStyleRegular, emSize, Point(0, 100), NULL); // 847 个点</span><br><span class="line">Pen pen(Color::Red); graph.DrawPath(&amp;pen, &amp;path); </span><br><span class="line">pOutlinePath = path.Clone(); </span><br><span class="line">pOutlinePath-&amp;gt;Outline(); </span><br><span class="line">PathGradientBrush pgBrush(pOutlinePath);</span><br><span class="line">int n = pOutlinePath-&amp;gt;GetPointCount(); // 1023 个点</span><br><span class="line">Color *cols = new Color[n]<span class="comment">;</span></span><br><span class="line">for (<span class="name">int</span> i = <span class="number">0</span><span class="comment">; i &amp;lt; n; i++) </span></span><br><span class="line">    cols[i] = Color(<span class="name">rand</span>() % <span class="number">255</span>, rand() % <span class="number">255</span>, rand() % <span class="number">255</span>)<span class="comment">;</span></span><br><span class="line">pgBrush.SetCenterColor(<span class="name">Color</span>(<span class="name">rand</span>() % <span class="number">255</span>, rand() % <span class="number">255</span>, rand() % <span class="number">255</span>))<span class="comment">; </span></span><br><span class="line">pgBrush.SetSurroundColors(<span class="name">cols</span>, <span class="symbol">&amp;n</span>)<span class="comment">; </span></span><br><span class="line">graph.TranslateTransform(<span class="number">0.0</span>f, <span class="number">100.0</span>f)<span class="comment">; </span></span><br><span class="line">graph.FillPath(<span class="name">&amp;pgBrush</span>, <span class="symbol">&amp;path</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>中，由于彩心字用到了随机颜色，所以每次刷新时的颜色都不一样。</p>
<p><img src="../img/gdip-编程基础/Image_074.jpg" alt="image"></p>
<p>图 14-47 普通、空心和彩心字符串</p>
<h3 id="1-8-4-平滑处理与-ClearType-技术"><a href="#1-8-4-平滑处理与-ClearType-技术" class="headerlink" title="1.8.4 平滑处理与 ClearType 技术"></a>1.8.4 平滑处理与 ClearType 技术</h3><p>为了提高文字的清晰度，需要对绘制的文本串进行平滑处理，防止在（特别是点阵）文 字被放大后出现明显的锯齿（马赛克 mosaic）现象。ClearType（清晰活字）是微软公司于 1999 年 4 月 7 日推出的一种图形显示技术，主要用于改善 LCD（Liquid Crystal Display，液 晶显示）显示器的显示效果，提高图形和文字的清晰度。</p>
<p>可以在 GDI+程序中，利用 Graphics 类的两个文本绘制提示（hint）方法：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TextRenderingHint GetTextRender ingHint(<span class="name">VOID</span>) const<span class="comment">; </span></span><br><span class="line">Status SetTextRenderingHint(<span class="name">TextRender</span> ingHint newMode)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>来获取和设置文字绘制时的平滑处理方法。其中的枚举类型 TextRenderingHint 的定义为：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    TextRenderingHintSystemDefault = <span class="number">0</span>, <span class="comment">// 同系统平滑方式 </span></span><br><span class="line">    TextRenderingHintSingleBitPerPixelGr idFit = <span class="number">1</span>, <span class="comment">// 不消锯齿，网格匹配 </span></span><br><span class="line">    TextRenderingHintSingleBitPerPixel = <span class="number">2</span>, <span class="comment">// 不消锯齿，不网格匹配 </span></span><br><span class="line">    TextRenderingHintAntiAliasGridFit = <span class="number">3</span>, <span class="comment">// 消锯齿，网格匹配 </span></span><br><span class="line">    TextRenderingHintAntiAlias = <span class="number">4</span>, <span class="comment">// 锯齿，不网格匹配</span></span><br><span class="line">    TextRenderingHintClearTypeGridFit = <span class="number">5</span> <span class="comment">// 使用 ClearType 技术，不网格匹配</span></span><br><span class="line">&#125; TextRenderingHint;</span><br></pre></td></tr></table></figure>
<p>这里的网格匹配（grid fit），主要是指在文本绘制时，通过调整字形的平直和垂直笔画的宽 度，以达到提高文字输出质量的一种方法。</p>
<p>例如（输出结果如图 14-48，为放大后的效果）：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Graphics graph(<span class="name">pDC-&amp;gt</span><span class="comment">;m_hDC);</span></span><br><span class="line">SolidBrush textBrush(<span class="name">Color</span>:<span class="symbol">:Black</span>)<span class="comment">; </span></span><br><span class="line">Font font(<span class="name">L</span><span class="string">"Arial"</span>, <span class="number">16</span>)<span class="comment">;</span></span><br><span class="line">CString str = L<span class="string">"font smoothing"</span><span class="comment">; </span></span><br><span class="line">wchar_t buf[<span class="number">5</span>]<span class="comment">;</span></span><br><span class="line">for (<span class="name">int</span> i = <span class="number">0</span><span class="comment">; i &amp;lt; 6; i++) &#123;</span></span><br><span class="line">    _itow_s(<span class="name">i</span>, buf, <span class="number">5</span>, <span class="number">10</span>)<span class="comment">; </span></span><br><span class="line">    graph.SetTextRenderingHint(<span class="name">TextRenderingHint</span>(<span class="name">i</span>))<span class="comment">; </span></span><br><span class="line">    graph.DrawString(<span class="name">buf</span>, <span class="number">-1</span>, <span class="symbol">&amp;font</span>, PointF(<span class="number">5.0</span>f, <span class="number">20.0</span>f * i), &amp;textBrush);</span><br><span class="line">    graph.DrawString(str, str.GetLength(), &amp;font, PointF(30.0f, 20.0f * i), <span class="symbol">&amp;textBrush</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="../img/gdip-编程基础/Image_075.jpg" alt="image"></p>
<p>图 14-48 文字绘制时的平滑处理方式 细心的同学可能会发现，除了渐变和路径刷及平滑处理外，大多数文本输出功能，GDI</p>
<p>都有。而且 GDI 还可以以任意角度绘制文本串，但是 GDI+好像不能。其实，这可以利用 GDI+的矩阵变换来实现。矩阵变换的内容，会在后面的 14.2.8 小节介绍。</p>
<p>专用字体集</p>
<p>如果你想使用系统中还没有被安装的字体，有如下两种方法可供选择。</p>
<p>（1）手工安装字体</p>
<p>选择 Windows XP 操作系统的“../控制面板/字体”图标，启动“字体”程序； 然后再选择“文件/安装新字体”菜单项，打开“添加字体”对话框（参见图 14-49）；选择 字体所在的文件目录，会出现目录中所有字体的名称和类型列表；选中想安装的字体后，按 确定关闭对话框。这样，就完成了字体的安装工作。将字体装进系统后，就可以和其他已装 入字体一样正常使用了。</p>
<p><img src="../img/gdip-编程基础/Image_076.jpg" alt="image"></p>
<p>图 14-49 添加字体对话框</p>
<p>（2）使用专用字体集</p>
<p>与已安装字体集类 InstalledFontCollection 一 样 ， 专 用 （ 私 有 ） 字 体 集 类 PrivateFontCollection 也是字体集类 FontCollection 的派生类。</p>
<p>PrivateFontCollection 类只有一个构造一个空的字体集默认构造函数：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PrivateFontCollection(<span class="name">VOID</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>但是可用方法 AddFontFile 来向字体集中添加字体文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">AddFontFile</span><span class="params">(<span class="keyword">const</span> WCHAR* filename)</span></span>;</span><br></pre></td></tr></table></figure>
<p>将字体文件加入专用字体集后，我们就可以利用其父类的方法</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Status GetLastStatus(<span class="name">VOID</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>和 GetFamilyCount、GetFamilies 等，来判断装入是否成功、字体集中共有多少种字体、获 取指定数目的字体族 FontFamily 对象的数组（指针）。这些都与前面“显示当前系统已装入 的字体（族）名称”部分所讲的类似。包括用 FontFamily 类的 GetFamilyName 方法获取字 体名称，并用该名称来创建字体对象（使用带字体集参数的构造函数），最后绘制文本串。</p>
<p>下面的例子，使用汉鼎繁印篆和汉鼎繁特行两种专用字体，输出文本串“专用字体集： 字体名称”和诗句“三顾频烦天下计 两朝开济老臣心”（参见图 14-50）。这两种字体所对应的字体文件 HDZB_25.TTF 和 HDZB_16.TTF，已经放入我个人网页的资源子目录 res 中。</p>
<p>你也可以自己从网上下载其他字体文件来进行试验。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 装入专用字体文件 </span></span><br><span class="line">PrivateFontCollection pfc; </span><br><span class="line">pfc.AddFontFile(L<span class="string">"res\\HDZB_16.TTF"</span>);</span><br><span class="line"><span class="keyword">if</span>(pfc.GetLastStatus() != Ok)</span><br><span class="line">&#123; </span><br><span class="line">    MessageBox(L<span class="string">"装入字体文件出错！"</span>); </span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">&#125; </span><br><span class="line">pfc.AddFontFile(L<span class="string">"res\\HDZB_25.TTF"</span>);</span><br><span class="line"><span class="keyword">if</span>(pfc.GetLastStatus() != Ok)</span><br><span class="line">&#123; </span><br><span class="line">    MessageBox(L<span class="string">"装入字体文件出错！"</span>); </span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">int</span> n = pfc.GetFamilyCount();</span><br><span class="line"><span class="keyword">if</span> (n &amp;lt; <span class="number">2</span>) </span><br><span class="line">&#123; </span><br><span class="line">    MessageBox(L<span class="string">"字体集中的字体数不够！"</span>); </span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取字体族对象数组 </span></span><br><span class="line">FontFamily ffs[<span class="number">2</span>]; </span><br><span class="line"><span class="built_in">int</span> found;</span><br><span class="line">pfc.GetFamilies(<span class="number">2</span>, ffs, &amp;found);</span><br><span class="line"><span class="comment">// 定义输出字符串</span></span><br><span class="line">CString str0 = L<span class="string">"专用字体集："</span>, <span class="built_in">str</span>;</span><br><span class="line">CString str1 = L<span class="string">"三顾频烦天下计\r\n 两朝开济老臣心"</span>;</span><br><span class="line"><span class="comment">// 设置中对齐</span></span><br><span class="line">StringFormat stringFormat; </span><br><span class="line">stringFormat.SetAlignment(StringAlignmentCenter); </span><br><span class="line">RECT <span class="built_in">rect</span>;</span><br><span class="line">GetClientRect(&amp;<span class="built_in">rect</span>);</span><br><span class="line"><span class="comment">// 创建图形和文本刷对象</span></span><br><span class="line">Graphics graph(pDC-&gt;m_hDC); </span><br><span class="line">SolidBrush textBrush(Color::Black);</span><br><span class="line"><span class="comment">// 获取字体名称 1，构造字体 1，并输出字符串</span></span><br><span class="line">wchar_t name[LF_FACESIZE]; </span><br><span class="line">ffs[<span class="number">0</span>].GetFamilyName(name);</span><br><span class="line">Font font1(name, <span class="number">60</span>, FontStyleRegular, UnitPixel, &amp;pfc); </span><br><span class="line"><span class="built_in">str</span> = str0 + name;</span><br><span class="line">graph.DrawString(<span class="built_in">str</span>, <span class="built_in">str</span>.GetLength(), &amp;font1, PointF(<span class="number">0.0</span>f, <span class="number">0.0</span>f), &amp;textBrush);</span><br><span class="line">graph.DrawString(str1, str1.GetLength(), &amp;font1, </span><br><span class="line">    PointF(<span class="built_in">rect</span>.right / <span class="number">2.0</span>f, <span class="number">80.0</span>f), &amp;stringFormat,</span><br><span class="line">    &amp;textBrush);</span><br><span class="line"><span class="comment">// 获取字体名称 2，构造字体 2，并输出字符串 ffs[1].GetFamilyName(name);</span></span><br><span class="line">Font font2(name, <span class="number">60</span>, FontStyleRegular, UnitPixel, &amp;pfc); </span><br><span class="line"><span class="built_in">str</span> = str0 + name;</span><br><span class="line">graph.DrawString(<span class="built_in">str</span>, <span class="built_in">str</span>.GetLength(), &amp;font2,</span><br><span class="line">    PointF(<span class="number">0.0</span>f, <span class="number">220.0</span>f), &amp;textBrush); graph.DrawString(str1, str1.GetLength(), &amp;font2,</span><br><span class="line">    PointF(<span class="built_in">rect</span>.right / <span class="number">2.0</span>f, <span class="number">300.0</span>f), &amp;stringFormat,</span><br><span class="line">    &amp;textBrush);</span><br></pre></td></tr></table></figure>
<p><img src="../img/gdip-编程基础/Image_077.jpg" alt="image"></p>
<p>图 14-50 使用汉鼎繁印篆和汉鼎繁特行专用字体</p>
<h2 id="复习思考题"><a href="#复习思考题" class="headerlink" title="复习思考题"></a>复习思考题</h2><p>1. GDI+与 GDI 是什么关系？</p>
<p>2. GDI+有哪两种封装？它们的基础是什么？</p>
<p>3. GDI+有哪些新增功能？</p>
<p>4. GDI+的绘图方式与 GDI 有什么不同？</p>
<p>5. 用 MFC 编写 GDI+程序需要做那些装备工作？对 VC08 SP1 及 VC10 版有什么不同？</p>
<p>6. 如何对 GDI+进行初始化和清除？需要特别注意什么？</p>
<p>7. 怎么解决 GDI+编程中 new 操作符问题？</p>
<p>8. GDI+的几何辅助类与 GDI 的有哪些不同？</p>
<p>9. 与 GDI 相比，GDI+的颜色哪些新内容？</p>
<p>10. 有多少颜色枚举常量？如何使用它们？GDI+的 Graphics 类与 GDI 的 MFC 封装中的什么类相似？怎样创建 Graphics 对象？</p>
<p>13. GDI+的绘图方法属于哪个类？</p>
<p>14. GDI+的画线方法的名称都有什么共同的前缀？</p>
<p>15. GDI+的画直线、矩形和椭圆的方法与 GDI 的对应方法有哪些不同？</p>
<p>16. GDI+中的画填充图的方法都有什么共同的前缀？有例外吗？</p>
<p>17. GDI+画填充多边形有哪两种填充模式？它们的差别在哪里？</p>
<p>18. GDI+提供了哪两种由控制点列画曲线的方法？它们有什么差别？</p>
<p>19. GDI+中有专门的清屏方法吗？GDI 中有没有？</p>
<p>20. 与 GDI 相比，GDI+中的笔增加了哪些新功能？</p>
<p>21. GDI+的条纹刷和纹理刷与 GDI 相比有哪些新加内容？</p>
<p>22. GDI+新增加了哪些画刷种类？</p>
<p>23. GDI+中有哪些字体类？</p>
<p>24. 在 VC08 SP1 及 VC10 中直接使用 Font 类会出现什么编译错误？如何解决？</p>
<p>25. 在 GDI+中如何使用字体？</p>
<p>26. GDI+使用什么方法绘制文本？</p>
<p>27. 如何实现阴影、条纹、纹理、渐变、空心和彩心等绘制美术字效果？</p>
<p>28. 如何使用专用字体集？</p>
<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><p>1. （选做题，例子）实现本章中的各例。</p>
<p>2. （正叶曲线）编写一个画填充正叶曲线的通用程序。可以指定叶片数、颜色、圆心和叶长（半径）等。（参见 14.7.2 的 2．和图 14-31）</p>
<p>3. （阴阳八卦图）编写一个绘制阴阳八卦图的通用程序。可指定各种颜色、圆心和半径等 等，参见图 14-51。</p>
<p><img src="../img/gdip-编程基础/Image_078.jpg" alt="image"></p>
<p>图 14-51 阴阳八卦图</p>
<p>4. （选做题，交互绘图）编写一个使用 GDI+接口的交互式绘图程序，实现 GDI+的所有 基本功能和各种新增加的功能。（提示，可以用 GDI 交互移动，用 GDI+成图。）</p>
<p>5. （选做题，补充绘图方法）编写若干（带不同类型输入参数的）画（线框和填充）弓弦 和 圆 角 矩 形 的 GDI+ 方法 （ DrawChord 、 FillChord 、 DrawRoundRectangle 和 FillRoundRectangle）。</p>
<p>6. （选做题，色块）绘制颜色枚举常量色块图。</p>

      
    </div>
    <footer class="article-footer">
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/ebook/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/ebook/tags/gdip/">gdip</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/ebook/tags/mfc/">mfc</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/ebook/2016-99a6ce9/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          习科SQL注入自学指南
        
      </div>
    </a>
  
  
    <a href="/ebook/2016-d2a616bb/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">android 逆向菜鸟速参手册（完蛋版）</div>
    </a>
  
</nav>

  
</article>


<section id="comments"></section>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
    var labels = "blog,gitment";
    labels = labels.split(",");
    var gitment = new Gitment({
        id: window.location.pathname,
        owner: 'hifor',
        repo: 'github-pages-comment',
        oauth: {
            client_id: '4eed20bfa5f203afa32c',
            client_secret: 'f9f85f592016611bddfa1f3f2aa4500f016931d3'
        },
        labels: labels
    })
    gitment.render('comments');
</script>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/android/">android</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/asp-net/">asp.net</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/c/">c</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/c/">c++</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/cpp/">cpp</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/csharp/">csharp</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/css/">css</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/git/">git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/html/">html</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/java/">java</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/java-web/">java web</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/javascript/">javascript</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/jquery/">jquery</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/linux/">linux</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/lisp/">lisp</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/matlab/">matlab</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/node-js/">node.js</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/opengl/">opengl</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/os/">os</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/php/">php</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/python/">python</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/ruby/">ruby</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/seo/">seo</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/unity3d/">unity3d</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/windows/">windows</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/产品/">产品</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/其它/">其它</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/分布式/">分布式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/安全/">安全</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/工程/">工程</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/数学·数理逻辑/">数学·数理逻辑</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/数据库/">数据库</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/数据库-nosql/">数据库 - nosql</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/数据挖掘/">数据挖掘</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/数据结构·算法/">数据结构·算法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/测试/">测试</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/算法/">算法</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/组成原理/">组成原理</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/编程思想/">编程思想</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/编译/">编译</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/网络/">网络</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/计算机文化/">计算机文化</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/设计/">设计</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/设计模式·架构/">设计模式·架构</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/ebook/categories/逆向工程/">逆向工程</a><span class="category-list-count">6</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/ebook/tags/android/" style="font-size: 14.38px;">android</a> <a href="/ebook/tags/angularjs/" style="font-size: 10.63px;">angularjs</a> <a href="/ebook/tags/apache/" style="font-size: 10px;">apache</a> <a href="/ebook/tags/asp/" style="font-size: 11.25px;">asp</a> <a href="/ebook/tags/asp-net/" style="font-size: 13.75px;">asp.net</a> <a href="/ebook/tags/atom/" style="font-size: 10px;">atom</a> <a href="/ebook/tags/beautifulsoup/" style="font-size: 10px;">beautifulsoup</a> <a href="/ebook/tags/boost/" style="font-size: 11.25px;">boost</a> <a href="/ebook/tags/bootstrap/" style="font-size: 10.63px;">bootstrap</a> <a href="/ebook/tags/c/" style="font-size: 13.75px;">c</a> <a href="/ebook/tags/c/" style="font-size: 14.38px;">c++</a> <a href="/ebook/tags/chrome/" style="font-size: 10.63px;">chrome</a> <a href="/ebook/tags/coffeescript/" style="font-size: 10.63px;">coffeescript</a> <a href="/ebook/tags/cpp/" style="font-size: 18.75px;">cpp</a> <a href="/ebook/tags/csharp/" style="font-size: 15px;">csharp</a> <a href="/ebook/tags/css/" style="font-size: 10.63px;">css</a> <a href="/ebook/tags/ctf/" style="font-size: 10px;">ctf</a> <a href="/ebook/tags/d3-js/" style="font-size: 10.63px;">d3.js</a> <a href="/ebook/tags/django/" style="font-size: 14.38px;">django</a> <a href="/ebook/tags/ejs/" style="font-size: 10px;">ejs</a> <a href="/ebook/tags/express-js/" style="font-size: 10px;">express.js</a> <a href="/ebook/tags/flask/" style="font-size: 11.88px;">flask</a> <a href="/ebook/tags/fltk/" style="font-size: 10px;">fltk</a> <a href="/ebook/tags/foundation/" style="font-size: 10px;">foundation</a> <a href="/ebook/tags/gdip/" style="font-size: 10.63px;">gdip</a> <a href="/ebook/tags/gimp/" style="font-size: 10px;">gimp</a> <a href="/ebook/tags/git/" style="font-size: 13.75px;">git</a> <a href="/ebook/tags/gnuplot/" style="font-size: 10px;">gnuplot</a> <a href="/ebook/tags/go/" style="font-size: 13.13px;">go</a> <a href="/ebook/tags/guava/" style="font-size: 10px;">guava</a> <a href="/ebook/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/ebook/tags/hibernate/" style="font-size: 10px;">hibernate</a> <a href="/ebook/tags/highcharts/" style="font-size: 10px;">highcharts</a> <a href="/ebook/tags/html/" style="font-size: 10px;">html</a> <a href="/ebook/tags/intellij-idea/" style="font-size: 10px;">intellij idea</a> <a href="/ebook/tags/ionic/" style="font-size: 10.63px;">ionic</a> <a href="/ebook/tags/ios/" style="font-size: 12.5px;">ios</a> <a href="/ebook/tags/it人文/" style="font-size: 11.25px;">it人文</a> <a href="/ebook/tags/java/" style="font-size: 17.5px;">java</a> <a href="/ebook/tags/javascript/" style="font-size: 19.38px;">javascript</a> <a href="/ebook/tags/jfreechart/" style="font-size: 10px;">jfreechart</a> <a href="/ebook/tags/jinja2/" style="font-size: 10px;">jinja2</a> <a href="/ebook/tags/jquery/" style="font-size: 13.75px;">jquery</a> <a href="/ebook/tags/jquerymobile/" style="font-size: 11.25px;">jquerymobile</a> <a href="/ebook/tags/jqueryui/" style="font-size: 10.63px;">jqueryui</a> <a href="/ebook/tags/jsp/" style="font-size: 10.63px;">jsp</a> <a href="/ebook/tags/kali/" style="font-size: 10.63px;">kali</a> <a href="/ebook/tags/kotlin/" style="font-size: 10.63px;">kotlin</a> <a href="/ebook/tags/laravel/" style="font-size: 10.63px;">laravel</a> <a href="/ebook/tags/linux/" style="font-size: 16.25px;">linux</a> <a href="/ebook/tags/lua/" style="font-size: 10.63px;">lua</a> <a href="/ebook/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/ebook/tags/matplotlib/" style="font-size: 10px;">matplotlib</a> <a href="/ebook/tags/memcached/" style="font-size: 10px;">memcached</a> <a href="/ebook/tags/metasploit/" style="font-size: 10px;">metasploit</a> <a href="/ebook/tags/mfc/" style="font-size: 11.25px;">mfc</a> <a href="/ebook/tags/mongodb/" style="font-size: 10.63px;">mongodb</a> <a href="/ebook/tags/mvc/" style="font-size: 10px;">mvc</a> <a href="/ebook/tags/mybatis/" style="font-size: 10px;">mybatis</a> <a href="/ebook/tags/mysql/" style="font-size: 11.88px;">mysql</a> <a href="/ebook/tags/nginx/" style="font-size: 10px;">nginx</a> <a href="/ebook/tags/nlp/" style="font-size: 10px;">nlp</a> <a href="/ebook/tags/node-js/" style="font-size: 15.63px;">node.js</a> <a href="/ebook/tags/nosql/" style="font-size: 10px;">nosql</a> <a href="/ebook/tags/numpy/" style="font-size: 10.63px;">numpy</a> <a href="/ebook/tags/nw-js/" style="font-size: 10px;">nw.js</a> <a href="/ebook/tags/octave/" style="font-size: 10px;">octave</a> <a href="/ebook/tags/opengl/" style="font-size: 10px;">opengl</a> <a href="/ebook/tags/orm2/" style="font-size: 10px;">orm2</a> <a href="/ebook/tags/os/" style="font-size: 11.88px;">os</a> <a href="/ebook/tags/php/" style="font-size: 11.88px;">php</a> <a href="/ebook/tags/postgresql/" style="font-size: 10px;">postgresql</a> <a href="/ebook/tags/python/" style="font-size: 20px;">python</a> <a href="/ebook/tags/qt/" style="font-size: 11.25px;">qt</a> <a href="/ebook/tags/react/" style="font-size: 10.63px;">react</a> <a href="/ebook/tags/redis/" style="font-size: 11.25px;">redis</a> <a href="/ebook/tags/ruby/" style="font-size: 10.63px;">ruby</a> <a href="/ebook/tags/scala/" style="font-size: 10px;">scala</a> <a href="/ebook/tags/scipy/" style="font-size: 11.25px;">scipy</a> <a href="/ebook/tags/selenium/" style="font-size: 10.63px;">selenium</a> <a href="/ebook/tags/seo/" style="font-size: 10px;">seo</a> <a href="/ebook/tags/servlet/" style="font-size: 11.25px;">servlet</a> <a href="/ebook/tags/sphinx/" style="font-size: 10px;">sphinx</a> <a href="/ebook/tags/spring/" style="font-size: 11.25px;">spring</a> <a href="/ebook/tags/sql/" style="font-size: 10.63px;">sql</a> <a href="/ebook/tags/sqlalchemy/" style="font-size: 10px;">sqlalchemy</a> <a href="/ebook/tags/sqlite/" style="font-size: 11.25px;">sqlite</a> <a href="/ebook/tags/sqlserver/" style="font-size: 10px;">sqlserver</a> <a href="/ebook/tags/swift/" style="font-size: 11.88px;">swift</a> <a href="/ebook/tags/tornado/" style="font-size: 10px;">tornado</a> <a href="/ebook/tags/typescript/" style="font-size: 10px;">typescript</a> <a href="/ebook/tags/unity3d/" style="font-size: 10px;">unity3d</a> <a href="/ebook/tags/vb-net/" style="font-size: 10px;">vb.net</a> <a href="/ebook/tags/vbs/" style="font-size: 11.25px;">vbs</a> <a href="/ebook/tags/velocity/" style="font-size: 10px;">velocity</a> <a href="/ebook/tags/vim/" style="font-size: 10px;">vim</a> <a href="/ebook/tags/vs2010/" style="font-size: 10px;">vs2010</a> <a href="/ebook/tags/vue-js/" style="font-size: 10px;">vue.js</a> <a href="/ebook/tags/webgl/" style="font-size: 10px;">webgl</a> <a href="/ebook/tags/weka/" style="font-size: 10px;">weka</a> <a href="/ebook/tags/werkzurg/" style="font-size: 10px;">werkzurg</a> <a href="/ebook/tags/windows/" style="font-size: 10px;">windows</a> <a href="/ebook/tags/wireshark/" style="font-size: 10.63px;">wireshark</a> <a href="/ebook/tags/wordpress/" style="font-size: 10px;">wordpress</a> <a href="/ebook/tags/wtl/" style="font-size: 10px;">wtl</a> <a href="/ebook/tags/wxwidgets/" style="font-size: 10px;">wxwidgets</a> <a href="/ebook/tags/xml/" style="font-size: 10.63px;">xml</a> <a href="/ebook/tags/yii/" style="font-size: 10px;">yii</a> <a href="/ebook/tags/zepto-js/" style="font-size: 10px;">zepto.js</a> <a href="/ebook/tags/中间件/" style="font-size: 10px;">中间件</a> <a href="/ebook/tags/入门/" style="font-size: 10.63px;">入门</a> <a href="/ebook/tags/入门指南/" style="font-size: 11.25px;">入门指南</a> <a href="/ebook/tags/分布式/" style="font-size: 10px;">分布式</a> <a href="/ebook/tags/图像处理/" style="font-size: 10px;">图像处理</a> <a href="/ebook/tags/图形/" style="font-size: 10px;">图形</a> <a href="/ebook/tags/工程/" style="font-size: 10px;">工程</a> <a href="/ebook/tags/操作系统/" style="font-size: 11.88px;">操作系统</a> <a href="/ebook/tags/数据挖掘/" style="font-size: 11.25px;">数据挖掘</a> <a href="/ebook/tags/数据结构·算法/" style="font-size: 13.75px;">数据结构·算法</a> <a href="/ebook/tags/数理逻辑·数学/" style="font-size: 10px;">数理逻辑·数学</a> <a href="/ebook/tags/正则表达式/" style="font-size: 10px;">正则表达式</a> <a href="/ebook/tags/汇编/" style="font-size: 10.63px;">汇编</a> <a href="/ebook/tags/测试/" style="font-size: 11.25px;">测试</a> <a href="/ebook/tags/消息/" style="font-size: 10px;">消息</a> <a href="/ebook/tags/渗透/" style="font-size: 18.13px;">渗透</a> <a href="/ebook/tags/科学计算/" style="font-size: 13.75px;">科学计算</a> <a href="/ebook/tags/算法/" style="font-size: 10px;">算法</a> <a href="/ebook/tags/综合/" style="font-size: 13.75px;">综合</a> <a href="/ebook/tags/编译/" style="font-size: 10px;">编译</a> <a href="/ebook/tags/网站建设/" style="font-size: 10px;">网站建设</a> <a href="/ebook/tags/网络/" style="font-size: 11.88px;">网络</a> <a href="/ebook/tags/计算机文化/" style="font-size: 16.88px;">计算机文化</a> <a href="/ebook/tags/设计模式/" style="font-size: 11.88px;">设计模式</a> <a href="/ebook/tags/逆向/" style="font-size: 16.25px;">逆向</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/ebook/archives/2018/06/">六月 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/ebook/archives/2016/04/">四月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/ebook/archives/2016/03/">三月 2016</a><span class="archive-list-count">72</span></li><li class="archive-list-item"><a class="archive-list-link" href="/ebook/archives/2016/02/">二月 2016</a><span class="archive-list-count">33</span></li><li class="archive-list-item"><a class="archive-list-link" href="/ebook/archives/2016/01/">一月 2016</a><span class="archive-list-count">84</span></li><li class="archive-list-item"><a class="archive-list-link" href="/ebook/archives/2015/12/">十二月 2015</a><span class="archive-list-count">27</span></li><li class="archive-list-item"><a class="archive-list-link" href="/ebook/archives/2015/11/">十一月 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/ebook/archives/2015/09/">九月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/ebook/archives/2015/07/">七月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/ebook/archives/2015/06/">六月 2015</a><span class="archive-list-count">28</span></li><li class="archive-list-item"><a class="archive-list-link" href="/ebook/archives/2015/05/">五月 2015</a><span class="archive-list-count">46</span></li><li class="archive-list-item"><a class="archive-list-link" href="/ebook/archives/2015/04/">四月 2015</a><span class="archive-list-count">100</span></li><li class="archive-list-item"><a class="archive-list-link" href="/ebook/archives/2015/03/">三月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/ebook/archives/2015/01/">一月 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/ebook/archives/2014/10/">十月 2014</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 IKin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/ebook/../" class="mobile-nav-link">Home</a>
  
    <a href="/ebook/../ebook/" class="mobile-nav-link">Ebook</a>
  
    <a href="/ebook/../about/" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/ebook/fancybox/jquery.fancybox.css">
  <script src="/ebook/fancybox/jquery.fancybox.pack.js"></script>


<script src="/ebook/js/script.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?2de072f84a3c26d66dbb30aeadaf3cbe";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


  </div>
</body>
</html>